/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/style/style.css":
/*!*****************************!*\
  !*** ./src/style/style.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://terminal-ui/./src/style/style.css?");

/***/ }),

/***/ "./src/ListHistory.ts":
/*!****************************!*\
  !*** ./src/ListHistory.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ListHistory = void 0;\r\nclass ListHistory {\r\n    constructor(length) {\r\n        this.length = length;\r\n        this.data = [];\r\n        this.lastIndex = 0;\r\n    }\r\n    add(item) {\r\n        if (this.lastIndex > this.length - 1) {\r\n            if (this.data[this.lastIndex - 1] == item) {\r\n                return;\r\n            }\r\n            this.lastIndex = this.length - 1;\r\n            for (let i = 0; i < this.data.length - 1; i++) {\r\n                this.data[i] = this.data[i + 1];\r\n            }\r\n        }\r\n        if (this.data[this.lastIndex - 1] == item) {\r\n            return;\r\n        }\r\n        this.data[this.lastIndex] = item;\r\n        this.lastIndex++;\r\n    }\r\n    getElem(index) {\r\n        return this.data[index];\r\n    }\r\n    getList() {\r\n        return this.data;\r\n    }\r\n    getLength() {\r\n        return this.data.length;\r\n    }\r\n}\r\nexports.ListHistory = ListHistory;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/ListHistory.ts?");

/***/ }),

/***/ "./src/Parser.ts":
/*!***********************!*\
  !*** ./src/Parser.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Pair = exports.Parser = void 0;\r\nclass Parser {\r\n    static parsePath(path) {\r\n        let position = 0;\r\n        const pathTo = [];\r\n        while (position < path.length) {\r\n            pathTo[position] = path[position].split('/');\r\n            position++;\r\n        }\r\n        return pathTo;\r\n    }\r\n    static parse(line) {\r\n        const args = [];\r\n        const elems = [];\r\n        const kw = /\\s*(cd|mkdir|rmdir|touch|rm|ls|pwd|cat|echo|help|clear)\\b/;\r\n        const flags = /\\s*-(-help|p|d|r|f|v|c|Q|1|s|S|t|l|E|n|b)+\\s*/g;\r\n        const text = /\\s*('[^\\']+')\\s*/;\r\n        const path = /\\s*([A-Za-z\\.\\-][A-Za-z0-9_\\-\\.]*\\/?)+\\s*/g;\r\n        const re = /[^>]*/;\r\n        let str = line;\r\n        let otherStr = '';\r\n        const index = line.indexOf('>');\r\n        if (index != -1) {\r\n            str = line.slice(0, index);\r\n            otherStr = line.slice(index);\r\n        }\r\n        let elem = str.match(kw);\r\n        if ((elem == null)) {\r\n            throw new Error('Bad command');\r\n        }\r\n        args.push(elem[0].trim());\r\n        str = str.replace(kw, '');\r\n        elem = str.match(flags);\r\n        if (args[0] == 'echo') {\r\n            elem = str.match(re);\r\n            if (elem == null) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            args.push(elem[0].trim());\r\n            args.push('-');\r\n            str = str.replace(re, '');\r\n        }\r\n        else {\r\n            if (elem != null) {\r\n                for (let i = 0; i < elem.length; i++) {\r\n                    elem[i] = elem[i].trim();\r\n                }\r\n                let flagsElem = elem.join('');\r\n                flagsElem = '-' + flagsElem.split('-').join('');\r\n                args.push(flagsElem);\r\n                str = str.replace(flags, '');\r\n            }\r\n            else {\r\n                args.push('-');\r\n            }\r\n            elem = str.match(text);\r\n            if (elem != null) {\r\n                args.push(elem[0]);\r\n                str = str.replace(text, '');\r\n            }\r\n            elem = str.match(path);\r\n            if (elem != null) {\r\n                let string = elem.join('');\r\n                string = string.trim();\r\n                args.push(string);\r\n                str = str.replace(path, '');\r\n            }\r\n        }\r\n        if (str != '') {\r\n            throw new Error('Invalid input');\r\n        }\r\n        if (otherStr != '') {\r\n            elems.push(...otherStr.split(' '));\r\n            if (elems.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            for (let i = 0; i < 2; i++) {\r\n                elems[i] = elems[i].trim();\r\n            }\r\n        }\r\n        return new Pair(args, elems);\r\n    }\r\n    static parseFlags(args, supportedFlagsList) {\r\n        if (args[1] == '-help') {\r\n            return new Set(['-help']);\r\n        }\r\n        return new Set(args\r\n            .filter(option => option.indexOf('-') === 0)\r\n            .map(option => option.replace('-', ''))\r\n            .join('')\r\n            .split('')\r\n            .filter(option => supportedFlagsList.includes(option)));\r\n    }\r\n}\r\nexports.Parser = Parser;\r\nclass Pair {\r\n    constructor(elem1, elem2) {\r\n        this.elem1 = elem1;\r\n        this.elem2 = elem2;\r\n    }\r\n    getElem1() {\r\n        return this.elem1;\r\n    }\r\n    getElem2() {\r\n        return this.elem2;\r\n    }\r\n}\r\nexports.Pair = Pair;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/Parser.ts?");

/***/ }),

/***/ "./src/Terminal.ts":
/*!*************************!*\
  !*** ./src/Terminal.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Terminal = void 0;\r\nconst FileSystemClient_1 = __webpack_require__(/*! ./fs/FileSystemClient */ \"./src/fs/FileSystemClient.ts\");\r\nconst Parser_1 = __webpack_require__(/*! ./Parser */ \"./src/Parser.ts\");\r\nconst ListHistory_1 = __webpack_require__(/*! ./ListHistory */ \"./src/ListHistory.ts\");\r\nclass Terminal {\r\n    constructor(fileSystem) {\r\n        this.handleInputCmdKeyDown = (event) => {\r\n            if (event.code == 'Enter') {\r\n                event.preventDefault();\r\n                this.sendCommand();\r\n                this.currentHistoryIndex = this.historyCommand.getLength();\r\n            }\r\n            else if ((event.code == 'ArrowUp' || event.code == 'ArrowDown')) {\r\n                event.preventDefault();\r\n                this.scrollCommand(event.code);\r\n            }\r\n        };\r\n        this.handleInputParamKeyDown = (event) => {\r\n            if (event.ctrlKey && event.code === 'KeyD') {\r\n                event.preventDefault();\r\n                this.sendParam();\r\n                this.inputParamElem.classList.add('hidden');\r\n                this.workLineElem.classList.remove('hidden');\r\n                this.inputCmdElem.focus();\r\n            }\r\n        };\r\n        this.handleInputCmdBlur = () => {\r\n            this.inputCmdElem.focus();\r\n        };\r\n        this.handleInputParamBlur = () => {\r\n            this.inputParamElem.focus();\r\n        };\r\n        this.client = new FileSystemClient_1.FileSystemClient(fileSystem);\r\n        this.historyCommand = new ListHistory_1.ListHistory(15);\r\n        this.terminalElem = document.createElement('div');\r\n        this.historyLogElem = document.createElement('div');\r\n        this.workLineElem = document.createElement('div');\r\n        this.pathElem = document.createElement('span');\r\n        this.inputCmdElem = document.createElement('span');\r\n        this.inputParamElem = document.createElement('span');\r\n        this.currentHistoryIndex = this.historyCommand.getLength();\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.terminalElem.id = 'terminal';\r\n        this.terminalElem.className = 'container';\r\n        this.historyLogElem.className = 'history__log';\r\n        this.workLineElem.className = 'work__line';\r\n        this.workLineElem.innerHTML = '<span class=\"initial__entry\">guest:</span>';\r\n        this.pathElem.className = 'path';\r\n        this.setPath('/');\r\n        this.inputCmdElem.className = 'input__cmd';\r\n        this.inputCmdElem.setAttribute('contenteditable', 'true');\r\n        this.inputCmdElem.setAttribute('autocorrect', 'off');\r\n        this.inputCmdElem.setAttribute('autocapitalize', 'none');\r\n        this.inputCmdElem.setAttribute('autocomplete', 'off');\r\n        this.inputCmdElem.addEventListener('blur', this.handleInputCmdBlur);\r\n        this.inputCmdElem.addEventListener('keydown', this.handleInputCmdKeyDown);\r\n        this.inputParamElem.classList.add('input__param', 'hidden');\r\n        this.inputParamElem.setAttribute('contenteditable', 'true');\r\n        this.inputParamElem.setAttribute('autocorrect', 'off');\r\n        this.inputParamElem.setAttribute('autocapitalize', 'none');\r\n        this.inputParamElem.setAttribute('autocomplete', 'off');\r\n        this.inputParamElem.addEventListener('blur', this.handleInputParamBlur);\r\n        this.inputParamElem.addEventListener('keydown', this.handleInputParamKeyDown);\r\n        this.workLineElem.appendChild(this.pathElem);\r\n        this.workLineElem.appendChild(this.inputCmdElem);\r\n        this.terminalElem.appendChild(this.historyLogElem);\r\n        this.terminalElem.appendChild(this.inputParamElem);\r\n        this.terminalElem.appendChild(this.workLineElem);\r\n        document.body.appendChild(this.terminalElem);\r\n        this.inputCmdElem.focus();\r\n    }\r\n    runCommand(args) {\r\n        var _a;\r\n        const cmd = args.getElem1();\r\n        const additionalArg = args.getElem2();\r\n        const commandName = cmd[0];\r\n        let str;\r\n        if (commandName == 'cd') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['-help']);\r\n            if (cmd.length == 3) {\r\n                const lastIndex = cmd.length - 1;\r\n                const path = cmd[lastIndex].split('/');\r\n                str = this.client.cd(path, flags);\r\n            }\r\n            else if (cmd.length == 2) {\r\n                str = this.client.cd([], flags);\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'mkdir') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['p', '-help']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split(' ');\r\n            str = this.client.mkdir(path, flags);\r\n        }\r\n        else if (commandName == 'echo') {\r\n            if (cmd.length != 3) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const content = this.client.echo(cmd[1]);\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else {\r\n                str = content;\r\n            }\r\n        }\r\n        else if (commandName == 'rmdir') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['p', '-help']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split('/');\r\n            str = this.client.rmdir(path, flags);\r\n        }\r\n        else if (commandName == 'touch') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['c', 'd', 'r', '-help']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split(' ');\r\n            if (cmd.length == 3 || cmd.length == 2) {\r\n                str = this.client.touch(path, flags);\r\n            }\r\n            else if (cmd.length == 4) {\r\n                const param = cmd[2];\r\n                str = this.client.touch(path, flags, param);\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'ls') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['l', 'Q', 't', 's', 'S', '-help']);\r\n            if (cmd.length == 2) {\r\n                const content = this.client.ls(flags).join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n                else {\r\n                    str = content;\r\n                }\r\n            }\r\n            else if (cmd.length == 3) {\r\n                const path = cmd[2].split('/');\r\n                const content = this.client.ls(flags, path).join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n                else {\r\n                    str = content;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'pwd') {\r\n            if (cmd.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['-help']);\r\n            const content = this.client.pwd(flags);\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else {\r\n                str = content;\r\n            }\r\n        }\r\n        else if (commandName == 'rm') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['r', 'f', 'v', 'd', '-help']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split(' ');\r\n            const content = (_a = this.client.rm(path, flags)) === null || _a === void 0 ? void 0 : _a.join('\\n');\r\n            if (additionalArg.length != 0 && content) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else {\r\n                str = content;\r\n            }\r\n        }\r\n        else if (commandName == 'cat') {\r\n            if (cmd.length == 2 && additionalArg.length == 2) {\r\n                return str;\r\n            }\r\n            else if (cmd.length == 3 || cmd.length == 2) {\r\n                const flags = Parser_1.Parser.parseFlags(cmd, ['E', 'n', 'b']);\r\n                const lastIndex = cmd.length - 1;\r\n                const path = cmd[lastIndex].split(' ');\r\n                const content = this.client.cat(path, flags).join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n                else {\r\n                    str = content;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'help') {\r\n            if (cmd.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const content = this.client.help().join('\\n');\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else {\r\n                str = content;\r\n            }\r\n        }\r\n        else if (commandName == 'clear') {\r\n            if (cmd.length > 2 || cmd[1] != '-') {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Bad command');\r\n        }\r\n        return str;\r\n    }\r\n    commandOutput(line) {\r\n        if (line.startsWith('cat >')) {\r\n            this.workLineElem.classList.add('hidden');\r\n            this.inputParamElem.classList.remove('hidden');\r\n            this.inputParamElem.setAttribute('command', line);\r\n            this.inputParamElem.focus();\r\n            return;\r\n        }\r\n        if (line === 'clear') {\r\n            this.historyLogElem.innerHTML = '';\r\n            return;\r\n        }\r\n        let output;\r\n        try {\r\n            const cmd = Parser_1.Parser.parse(line);\r\n            output = this.runCommand(cmd);\r\n        }\r\n        catch (error) {\r\n            output = error.message;\r\n        }\r\n        if (output) {\r\n            const outputCommand = output.split('\\n');\r\n            for (const item of outputCommand) {\r\n                const div = document.createElement('div');\r\n                div.className = 'output';\r\n                div.innerHTML = item;\r\n                this.historyLogElem.appendChild(div);\r\n            }\r\n        }\r\n    }\r\n    setPath(path) {\r\n        this.pathElem.innerText = `(${path})$`;\r\n    }\r\n    sendCommand() {\r\n        const command = this.inputCmdElem.innerText.trim();\r\n        this.historyLogElem.appendChild(this.workLineElem.cloneNode(true));\r\n        if (command != '') {\r\n            this.historyCommand.add(command);\r\n            this.commandOutput(command);\r\n        }\r\n        const path = this.client.pwd(new Set([])) == '/home' ? '/' : this.client.pwd(new Set([])).slice(5);\r\n        this.setPath(path);\r\n        this.inputCmdElem.innerText = '';\r\n    }\r\n    scrollCommand(str) {\r\n        if (this.historyCommand.getLength() == 0) {\r\n            return;\r\n        }\r\n        console.log(this.historyCommand.getList());\r\n        if (str == 'ArrowUp') {\r\n            this.currentHistoryIndex--;\r\n            if (this.currentHistoryIndex < 0) {\r\n                this.currentHistoryIndex = 0;\r\n            }\r\n            this.inputCmdElem.innerText = this.historyCommand.getElem(this.currentHistoryIndex);\r\n            const range = document.createRange();\r\n            range.selectNodeContents(this.inputCmdElem);\r\n            range.collapse(false);\r\n            const sel = window.getSelection();\r\n            if (sel == null) {\r\n                return;\r\n            }\r\n            sel.removeAllRanges();\r\n            sel.addRange(range);\r\n        }\r\n        else if (str == 'ArrowDown') {\r\n            this.currentHistoryIndex++;\r\n            if (this.currentHistoryIndex > this.historyCommand.getLength() - 1) {\r\n                this.currentHistoryIndex = this.historyCommand.getLength();\r\n                this.inputCmdElem.innerText = '';\r\n            }\r\n            else {\r\n                this.inputCmdElem.innerText = this.historyCommand.getElem(this.currentHistoryIndex);\r\n            }\r\n        }\r\n    }\r\n    sendParam() {\r\n        const str = this.inputParamElem.innerText.trim();\r\n        this.historyLogElem.appendChild(this.inputParamElem.cloneNode(true));\r\n        let cmd = this.inputParamElem.getAttribute('command');\r\n        if (cmd) {\r\n            const index = cmd.indexOf('>');\r\n            cmd = cmd.slice(index);\r\n            cmd = cmd.trim();\r\n            const re = />/g;\r\n            const counter = cmd.match(re);\r\n            const elems = cmd.split(' ');\r\n            for (let i = 0; i < 2; i++) {\r\n                elems[i] = elems[i].trim();\r\n            }\r\n            if ((counter === null || counter === void 0 ? void 0 : counter.length) == 1) {\r\n                this.client.setOutputInTargetFile(elems[1].split('/'), str);\r\n            }\r\n            else if ((counter === null || counter === void 0 ? void 0 : counter.length) == 2) {\r\n                this.client.cancateOutputInTargetFile(elems[1].split('/'), str);\r\n            }\r\n        }\r\n        this.inputParamElem.innerText = '';\r\n    }\r\n}\r\nexports.Terminal = Terminal;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/Terminal.ts?");

/***/ }),

/***/ "./src/fs/FileSystemClient.ts":
/*!************************************!*\
  !*** ./src/fs/FileSystemClient.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FileSystemClient = void 0;\r\nconst FsDir_1 = __webpack_require__(/*! ./FsDir */ \"./src/fs/FsDir.ts\");\r\nconst FsFile_1 = __webpack_require__(/*! ./FsFile */ \"./src/fs/FsFile.ts\");\r\nconst Parser_1 = __webpack_require__(/*! ../Parser */ \"./src/Parser.ts\");\r\n;\r\nclass FileSystemClient {\r\n    constructor(home) {\r\n        this.home = home;\r\n        this.pointer = home.getRoot();\r\n    }\r\n    cd(pathTo, flags) {\r\n        const currentDir = this.pointer;\r\n        let str;\r\n        if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n            str = 'cd: cd [DIR]\\n' +\r\n                'Change the shell working directiry.\\n' +\r\n                'Change the current directory to DIR.  The default DIR is the value of the\\n' +\r\n                'HOME shell variable.';\r\n            return str;\r\n        }\r\n        if (pathTo.length > 0) {\r\n            if (pathTo.length == 1 && pathTo[0] == '-') {\r\n                this.pointer = this.home.historyDir.getElem(0);\r\n            }\r\n            else {\r\n                let childDir;\r\n                let position = 0;\r\n                do {\r\n                    if (pathTo[position] == '..') {\r\n                        if (this.pointer == this.home.getRoot()) {\r\n                            this.pointer == this.home.getRoot();\r\n                        }\r\n                        else {\r\n                            this.pointer = this.pointer.parentDir;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (pathTo[position] == 'home' && position == 0) {\r\n                            this.pointer = this.home.getRoot();\r\n                        }\r\n                        else {\r\n                            childDir = this.pointer.get(pathTo[position]);\r\n                            if (!childDir) {\r\n                                this.pointer = currentDir;\r\n                                throw new Error(`${pathTo.join('/')} not found`);\r\n                            }\r\n                            if (!(childDir instanceof FsDir_1.FsDir)) {\r\n                                this.pointer = currentDir;\r\n                                throw new Error(`${pathTo.join('/')} is not a directory`);\r\n                            }\r\n                            this.pointer = childDir;\r\n                        }\r\n                    }\r\n                    position++;\r\n                } while (position < pathTo.length);\r\n            }\r\n        }\r\n        else {\r\n            this.pointer = this.home.getRoot();\r\n        }\r\n        this.home.historyDir.add(this.pointer);\r\n    }\r\n    mkdir(path, flags) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        let position = 0;\r\n        let elem = 0;\r\n        let str;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    this.addDir(pathTo[position][0]);\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                    this.addDir(pathTo[position][indexElem]);\r\n                }\r\n                this.pointer = currentDir;\r\n                position++;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n                str = 'Usage: mkdir [OPTION] DIRECTORY...\\n' +\r\n                    'Create the DIRECTORY(ies), if they do not already exist.\\n' +\r\n                    'flags:\\n' +\r\n                    '&emsp;&emsp;&nbsp;-p create parent directory\\n' +\r\n                    '--help display this help';\r\n            }\r\n            else if (this.hasAll(flags, 'p') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    while (elem < pathTo[position].length) {\r\n                        const childDir = this.addDir(pathTo[position][elem]);\r\n                        this.pointer = childDir;\r\n                        elem++;\r\n                    }\r\n                    this.pointer = currentDir;\r\n                    position++;\r\n                    elem = 0;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    rmdir(pathTo, flags) {\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        let str;\r\n        if (flags.size == 0) {\r\n            this.cd(pathTo.slice(0, pathTo.length), new Set([]));\r\n            if (this.pointer.content.length == 0) {\r\n                this.pointer.parentDir.removeThisDir(this.pointer);\r\n            }\r\n            else {\r\n                throw new Error('Directory must be empty');\r\n            }\r\n            this.pointer = currentDir;\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n                str = 'Usage: rmdir [OPTION] DIRECTORY...\\n' +\r\n                    'Remove the DIRECTORY(ies), if they are empty.\\n' +\r\n                    'flags:\\n' +\r\n                    '&emsp;&emsp;&nbsp;-p remove DIRECTORY and its ancestors\\n' +\r\n                    '--help display this help';\r\n            }\r\n            else if (this.hasAll(flags, 'p') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    this.cd(pathTo.slice(0, pathTo.length - position), new Set([]));\r\n                    if (this.pointer.content.length == 0) {\r\n                        this.pointer.parentDir.removeThisDir(this.pointer);\r\n                    }\r\n                    else {\r\n                        throw new Error('Directory must be empty');\r\n                    }\r\n                    this.pointer = currentDir;\r\n                    position++;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    touch(path, flags, param) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if ((param && !this.hasAll(flags, 'd')) || (!param && this.hasAll(flags, 'd'))) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        let str;\r\n        if (flags.size == 0 || (this.hasAll(flags, 'c') && flags.size == 1)) {\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    this.createFile(pathTo[position][0], this.hasAll(flags, 'c'));\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                    this.createFile(pathTo[position][indexElem], this.hasAll(flags, 'c'));\r\n                }\r\n                position++;\r\n                this.pointer = currentDir;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n                str = 'Usage: rmdir [OPTION] FILE...\\n' +\r\n                    'Update the access and modification times of each FILE to the current time.\\n' +\r\n                    'A FILE argument that does not exist is created empty, unless -c is supplied.\\n' +\r\n                    'flags:\\n' +\r\n                    '&emsp;&emsp;&nbsp;-c do not create any files\\n' +\r\n                    '&emsp;&emsp;&nbsp;-d parse STRING and use it instead of current time\\n' +\r\n                    '&emsp;&emsp;&nbsp;-r use this file\\'s times instead of current time\\n' +\r\n                    '--help display this help';\r\n            }\r\n            else if (this.hasAll(flags, 'd')) {\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.createFile(pathTo[position][0], this.hasAll(flags, 'c'), param);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        this.createFile(pathTo[position][indexElem], this.hasAll(flags, 'c'), param);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'r')) {\r\n                if (pathTo.length != 2) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                if (pathTo[0].length == 1) {\r\n                    const file1 = this.getFile(pathTo[0][0]);\r\n                    if (pathTo[1].length == 1) {\r\n                        this.pushLastMode(pathTo[1][0], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[1].length - 1;\r\n                        this.cd(pathTo[1].slice(0, indexElem), new Set([]));\r\n                        this.pushLastMode(pathTo[1][indexElem], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[0].length - 1;\r\n                    this.cd(pathTo[0].slice(0, indexElem), new Set([]));\r\n                    const file1 = this.getFile(pathTo[0][indexElem]);\r\n                    this.pointer = currentDir;\r\n                    if (pathTo[1].length == 1) {\r\n                        this.pushLastMode(pathTo[1][0], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[1].length - 1;\r\n                        this.cd(pathTo[1].slice(0, indexElem), new Set([]));\r\n                        this.pushLastMode(pathTo[1][indexElem], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                }\r\n                this.pointer = currentDir;\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    pwd(flags) {\r\n        const elemOfPath = [];\r\n        const currentDir = this.pointer;\r\n        let str;\r\n        if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n            str = 'pwd: pwd\\n' +\r\n                'Print the name of the current working directory.\\n' +\r\n                'A FILE argument that does not exist is created empty, unless -c is supplied.\\n' +\r\n                'flags:\\n' +\r\n                '--help display this help';\r\n            return str;\r\n        }\r\n        else if (flags.size == 0) {\r\n            while (this.pointer != this.home.getRoot()) {\r\n                elemOfPath.push(this.pointer.name);\r\n                this.pointer = this.pointer.parentDir;\r\n            }\r\n            this.pointer = currentDir;\r\n            elemOfPath.push('home');\r\n            const path = '/' + elemOfPath.reverse().join('/');\r\n            console.log(path);\r\n            return path;\r\n        }\r\n        else {\r\n            throw new Error('Invalid input');\r\n        }\r\n    }\r\n    rm(path, flags) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        let position = 0;\r\n        let strHelp;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            const str = [];\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                    this.messageErrorFile(pathTo[position][0], elemDel);\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                    const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                    this.messageErrorFile(pathTo[position][indexElem], elemDel);\r\n                }\r\n                position++;\r\n                this.pointer = currentDir;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n                strHelp = ['Usage: rm [OPTION]... FILE...',\r\n                    'Remove the FILE(s).',\r\n                    'flags:',\r\n                    '&emsp;&emsp;&nbsp;-f ignore nonexistent files, never prompt',\r\n                    '&emsp;&emsp;&nbsp;-r remove directories and their contents recursively',\r\n                    '&emsp;&emsp;&nbsp;-v explain what is being done',\r\n                    '&emsp;&emsp;&nbsp;-d remove empty directories',\r\n                    '--help display this help'];\r\n                return strHelp;\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'f', 'v') && flags.size == 3) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteDir(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        this.deleteDir(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'v') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteDir(pathTo[position][0], str);\r\n                        this.messageErrorDir(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        const elemDel = this.deleteDir(pathTo[position][indexElem], str);\r\n                        this.messageErrorDir(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'f') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteDir(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        this.deleteDir(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'v', 'f') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][0], str);\r\n                        }\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][indexElem], str);\r\n                        }\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'r') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteDir(pathTo[position][0], str);\r\n                        this.messageErrorDir(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        const elemDel = this.deleteDir(pathTo[position][indexElem], str);\r\n                        this.messageErrorDir(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'v') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][0], str);\r\n                        }\r\n                        this.messageError(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][indexElem], str);\r\n                        }\r\n                        this.messageError(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'f') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteFile(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem), new Set([]));\r\n                        this.deleteFile(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'd') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    this.rmdir(pathTo[position], new Set([]));\r\n                    position++;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n    }\r\n    ls(flags, pathTo) {\r\n        const elems = [];\r\n        const str = [];\r\n        const currentDir = this.pointer;\r\n        let strHelp;\r\n        if (pathTo) {\r\n            this.cd(pathTo, new Set([]));\r\n        }\r\n        if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n            strHelp = ['Usage: ls [OPTION]... [DIR]...',\r\n                'List information about the DIR.',\r\n                'flags:',\r\n                '&emsp;&emsp;&nbsp;-Q  enclose entry names in double quotes',\r\n                '&emsp;&emsp;&nbsp;-S  sort by file size, largest first',\r\n                '&emsp;&emsp;&nbsp;-s print the allocated size of each file, in blocks',\r\n                '&emsp;&emsp;&nbsp;-t sort by modification time, newest first',\r\n                '&emsp;&emsp;&nbsp;-l use a long listing format',\r\n                '--help display this help'];\r\n            return strHelp;\r\n        }\r\n        if (this.pointer.content.length == 0) {\r\n            str.push('&nbsp;');\r\n        }\r\n        else {\r\n            this.pointer.content.map(item => {\r\n                elems.push(item);\r\n                str.push(item.name);\r\n            });\r\n        }\r\n        if (this.hasAll(flags, 'Q')) {\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = '\"' + str[i] + '\"';\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'S')) {\r\n            for (let i = 0; i < elems.length - 1; i++) {\r\n                for (let j = i + 1; j < elems.length; j++) {\r\n                    if (elems[i].size < elems[j].size) {\r\n                        this.swap(elems, i, j);\r\n                        this.swap(str, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 't')) {\r\n            for (let i = 0; i < elems.length - 1; i++) {\r\n                for (let j = i + 1; j < elems.length; j++) {\r\n                    if (elems[i].lastmod < elems[j].lastmod) {\r\n                        this.swap(elems, i, j);\r\n                        this.swap(str, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'l')) {\r\n            let sum = 0;\r\n            let maxSizeLen = 0;\r\n            for (let i = 0; i < elems.length; i++) {\r\n                const elemLen = elems[i].size.toString().length;\r\n                if (maxSizeLen < elemLen) {\r\n                    maxSizeLen = elemLen;\r\n                }\r\n            }\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (elems[i] instanceof FsFile_1.FsFile) {\r\n                    sum += elems[i].size;\r\n                }\r\n                str[i] = this.collectString(elems[i]) + str[i];\r\n                const elemLen = elems[i].size.toString().length;\r\n                for (let j = 0; j < maxSizeLen - elemLen; j++) {\r\n                    str[i] = '&nbsp;' + str[i];\r\n                }\r\n            }\r\n            str.push('total ' + sum);\r\n        }\r\n        if (this.hasAll(flags, 's')) {\r\n            let sum = 0;\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (elems[i] instanceof FsFile_1.FsFile) {\r\n                    str[i] = elems[i].size.toString() + ' ' + str[i];\r\n                    sum += elems[i].size;\r\n                }\r\n                else {\r\n                    str[i] = '0 ' + str[i];\r\n                }\r\n            }\r\n            if (!(str.includes('total ' + sum))) {\r\n                str.push('total ' + sum);\r\n            }\r\n        }\r\n        if (str.length > elems.length) {\r\n            const sumElem = str.pop();\r\n            if (sumElem) {\r\n                str.unshift(sumElem);\r\n            }\r\n        }\r\n        str.map(item => {\r\n            console.log(item);\r\n        });\r\n        this.pointer = currentDir;\r\n        return str;\r\n    }\r\n    cat(source, flags) {\r\n        const sourcePath = Parser_1.Parser.parsePath(source);\r\n        const currentDir = this.pointer;\r\n        let str = [];\r\n        let position = 0;\r\n        let strHelp;\r\n        if (this.hasAll(flags, '-help') && flags.size == 1) {\r\n            strHelp = ['Usage: cat [OPTION]... [FILE]...',\r\n                'Concatenate FILE(s) to standard output.',\r\n                'With no FILE, or when FILE is -, read standard input.',\r\n                'flags:',\r\n                '&emsp;&emsp;&nbsp;-E display $ at end of each line',\r\n                '&emsp;&emsp;&nbsp;-n number all output lines',\r\n                '&emsp;&emsp;&nbsp;-b number nonempty output lines, overrides -n',\r\n                '--help display this help'];\r\n            return strHelp;\r\n        }\r\n        while (position < sourcePath.length) {\r\n            this.getContentInSourceFile(sourcePath, str, position);\r\n            this.pointer = currentDir;\r\n            position++;\r\n        }\r\n        const fullContent = str.join('\\n');\r\n        str = fullContent.split('\\n');\r\n        if (flags.size == 0) {\r\n            for (let i = 0; i < str.length; i++) {\r\n                if (str[i] == '' || str[i] == '&nbsp;')\r\n                    str[i] = '&nbsp;' + str[i];\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'E')) {\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = str[i] + '$';\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'n')) {\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = '&emsp;&emsp;' + (i + 1) + ' ' + str[i];\r\n            }\r\n        }\r\n        else if (this.hasAll(flags, 'b')) {\r\n            let counter = 1;\r\n            for (let i = 0; i < str.length; i++) {\r\n                if (str[i] != '&nbsp;' && str[i] != '') {\r\n                    str[i] = '&emsp;&emsp;' + counter + ' ' + str[i];\r\n                    counter++;\r\n                }\r\n                else {\r\n                    str[i] = '&nbsp;' + str[i];\r\n                }\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    echo(content) {\r\n        return content;\r\n    }\r\n    setOutputInTargetFile(targetPath, content) {\r\n        if (targetPath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        const currentDir = this.pointer;\r\n        this.putInTargetFile(targetPath, content, 1);\r\n        this.pointer = currentDir;\r\n    }\r\n    cancateOutputInTargetFile(targetPath, content) {\r\n        if (targetPath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        const currentDir = this.pointer;\r\n        this.putInTargetFile(targetPath, content, 2);\r\n        this.pointer = currentDir;\r\n    }\r\n    help() {\r\n        const str = [\r\n            \"cd [DIR] - changes the current folder.\" /* CD */,\r\n            \"mkdir [OPTION] [DIR]... - creates a directory.\" /* MKDIR */,\r\n            \"rmdir [OPTION] [DIR] - removes a directory if it is empty.\" /* RMDIR */,\r\n            \"touch [OPTION]... [FILE]... - creates a file.\" /* TOUCH */,\r\n            \"pwd - shows the path to the current directory.\" /* PWD */,\r\n            \"rm [OPTION]... [FILE]... - removes directory or file.\" /* RM */,\r\n            \"ls [OPTION]... [DIR] - shows directory contents.\" /* LS */,\r\n            \"cat [OPTION]... [FILE]... - print the contents of FILE (s) to standard output.\" /* CAT */,\r\n            \"echo [STRING] - print a string to standard output.\" /* ECHO */,\r\n            \"clear - clears the window.\" /* CLEAR */,\r\n            \"help - prints list commands.\" /* HELP */\r\n        ];\r\n        str.map(item => {\r\n            console.log(item);\r\n        });\r\n        return str;\r\n    }\r\n    getContentInSourceFile(source, str, index) {\r\n        if (source[index].length == 1) {\r\n            this.getContentFile(source[index][0], str);\r\n        }\r\n        else {\r\n            const indexElem = source[index].length - 1;\r\n            this.cd(source[index].slice(0, indexElem), new Set([]));\r\n            this.getContentFile(source[index][indexElem], str);\r\n        }\r\n    }\r\n    putInTargetFile(target, content, counter) {\r\n        if (target.length == 1) {\r\n            this.pushContentFile(target[0], content, counter);\r\n        }\r\n        else {\r\n            const indexElem = target.length - 1;\r\n            this.cd(target.slice(0, indexElem), new Set([]));\r\n            this.pushContentFile(target[indexElem], content, counter);\r\n        }\r\n    }\r\n    pushContentFile(path, str, counter) {\r\n        this.touch([path], new Set([]));\r\n        const file = this.pointer.get(path);\r\n        if (file instanceof FsFile_1.FsFile) {\r\n            if (counter == 1) {\r\n                file.setContent(str);\r\n            }\r\n            if (counter == 2) {\r\n                if (file.content != '') {\r\n                    file.concatContent('\\n' + str);\r\n                }\r\n                else {\r\n                    file.concatContent(str);\r\n                }\r\n            }\r\n        }\r\n        this.messageErrorFile(path, file);\r\n    }\r\n    getContentFile(path, str) {\r\n        const file = this.pointer.get(path);\r\n        if (file instanceof FsFile_1.FsFile) {\r\n            if (file.content.length == 0) {\r\n                str.push('&nbsp;');\r\n            }\r\n            else {\r\n                str.push(file.content);\r\n            }\r\n        }\r\n        this.messageErrorFile(path, file);\r\n    }\r\n    collectString(elem) {\r\n        const str = elem.size + ' ' + this.getMonth(elem.lastmod.getMonth()) + ' ' + this.checkTime(elem.lastmod.getDate()) + ' ' + this.checkTime(elem.lastmod.getHours()) + ':' + this.checkTime(elem.lastmod.getMinutes()) + ' ';\r\n        return str;\r\n    }\r\n    checkTime(time) {\r\n        if (time < 10) {\r\n            return '0' + time;\r\n        }\r\n        return time;\r\n    }\r\n    hasAll(set, ...elems) {\r\n        for (const elem of elems) {\r\n            if (!set.has(elem)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    deleteFile(path, str) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (fileInp instanceof FsFile_1.FsFile) {\r\n            str.push(fileInp.name);\r\n            this.pointer.remove(fileInp);\r\n        }\r\n        return fileInp;\r\n    }\r\n    deleteDir(path, str) {\r\n        const dirInp = this.pointer.get(path);\r\n        if (dirInp instanceof FsDir_1.FsDir) {\r\n            str.push(...this.removeAll(dirInp));\r\n        }\r\n        return dirInp;\r\n    }\r\n    messageErrorFile(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        if (elem instanceof FsDir_1.FsDir) {\r\n            throw new Error(`${path} is directory`);\r\n        }\r\n    }\r\n    messageErrorDir(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        if (elem instanceof FsFile_1.FsFile) {\r\n            throw new Error(`${path} is file`);\r\n        }\r\n    }\r\n    messageError(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n    }\r\n    createFile(path, availability, param) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (!(fileInp instanceof FsFile_1.FsFile) && !availability) {\r\n            const file = new FsFile_1.FsFile(path, '');\r\n            file.updateLastMode(param);\r\n            this.pointer.add(file);\r\n        }\r\n        else if (fileInp instanceof FsFile_1.FsFile) {\r\n            fileInp.updateLastMode(param);\r\n        }\r\n    }\r\n    pushLastMode(path, file, availability) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (!(fileInp instanceof FsFile_1.FsFile) && !availability) {\r\n            const file2 = new FsFile_1.FsFile(path, '');\r\n            file2.lastmod = file.lastmod;\r\n            this.pointer.add(file2);\r\n        }\r\n        else if (fileInp instanceof FsFile_1.FsFile) {\r\n            fileInp.lastmod = file.lastmod;\r\n        }\r\n    }\r\n    getFile(path) {\r\n        const file1 = this.pointer.get(path);\r\n        if (!(file1 instanceof FsFile_1.FsFile)) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        return file1;\r\n    }\r\n    removeAll(dir) {\r\n        const str = [];\r\n        while (dir.content.length > 0) {\r\n            const elem = dir.content.pop();\r\n            if (elem) {\r\n                str.push(elem.name);\r\n            }\r\n            if (elem instanceof FsDir_1.FsDir) {\r\n                str.push(...this.removeAll(elem));\r\n            }\r\n        }\r\n        if (dir.parentDir.get(dir.name)) {\r\n            dir.parentDir.content.splice(dir.parentDir.content.indexOf(dir), 1);\r\n            str.push(dir.name);\r\n        }\r\n        return str;\r\n    }\r\n    addDir(path) {\r\n        if (!(this.pointer.checkUnit(path, \"DIR\" /* DIR */))) {\r\n            throw new Error('Directory already exists');\r\n        }\r\n        const childDir = new FsDir_1.FsDir(path);\r\n        this.pointer.add(childDir);\r\n        return childDir;\r\n    }\r\n    swap(array, i, j) {\r\n        const tmp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = tmp;\r\n    }\r\n    getMonth(index) {\r\n        let month;\r\n        switch (index) {\r\n            case 0: {\r\n                month = 'Jan';\r\n                break;\r\n            }\r\n            case 1: {\r\n                month = 'Feb';\r\n                break;\r\n            }\r\n            case 2: {\r\n                month = 'Mar';\r\n                break;\r\n            }\r\n            case 3: {\r\n                month = 'Apr';\r\n                break;\r\n            }\r\n            case 4: {\r\n                month = 'May';\r\n                break;\r\n            }\r\n            case 5: {\r\n                month = 'Jun';\r\n                break;\r\n            }\r\n            case 6: {\r\n                month = 'Jul';\r\n                break;\r\n            }\r\n            case 7: {\r\n                month = 'Aug';\r\n                break;\r\n            }\r\n            case 8: {\r\n                month = 'Sept';\r\n                break;\r\n            }\r\n            case 9: {\r\n                month = 'Oct';\r\n                break;\r\n            }\r\n            case 10: {\r\n                month = 'Nov';\r\n                break;\r\n            }\r\n            case 11: {\r\n                month = 'Dec';\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error('error');\r\n            }\r\n        }\r\n        return month;\r\n    }\r\n}\r\nexports.FileSystemClient = FileSystemClient;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/fs/FileSystemClient.ts?");

/***/ }),

/***/ "./src/fs/FileSystemManager.ts":
/*!*************************************!*\
  !*** ./src/fs/FileSystemManager.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FileSystemManager = void 0;\r\nconst FsDir_1 = __webpack_require__(/*! ./FsDir */ \"./src/fs/FsDir.ts\");\r\nconst ListHistory_1 = __webpack_require__(/*! ../ListHistory */ \"./src/ListHistory.ts\");\r\nclass FileSystemManager {\r\n    constructor() {\r\n        this.root = new FsDir_1.FsDir(FsDir_1.FS_ROOT_NAME);\r\n        this.historyDir = new ListHistory_1.ListHistory(2);\r\n        this.historyDir.add(this.root);\r\n        this.fileSystem = new Map();\r\n        this.fileSystem.set(this.root, this.root.content);\r\n    }\r\n    getRoot() {\r\n        return this.root;\r\n    }\r\n    printDir(path) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        const arrayContent = this.fileSystem.get(parentDir);\r\n        if (arrayContent) {\r\n            for (const item of arrayContent) {\r\n                console.log(item);\r\n            }\r\n        }\r\n    }\r\n    getSizeDir(path) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        return parentDir.size;\r\n    }\r\n    addUnit(path, unit) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        if (!(parentDir.checkUnit(unit.name, \"DIR\" /* DIR */))) {\r\n            throw new Error('Element already exists');\r\n        }\r\n        parentDir.add(unit);\r\n        if (unit instanceof FsDir_1.FsDir) {\r\n            this.fileSystem.set(unit, unit.content);\r\n        }\r\n        return true;\r\n    }\r\n    removeUnit(path, unit) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        if (parentDir.checkUnit(unit.name, \"DIR\" /* DIR */)) {\r\n            throw new Error('Element not found');\r\n        }\r\n        parentDir.content.splice(parentDir.content.indexOf(unit), 1);\r\n        if (unit instanceof FsDir_1.FsDir) {\r\n            this.fileSystem.delete(unit);\r\n        }\r\n        return true;\r\n    }\r\n    get(fsUnitPath) {\r\n        if (fsUnitPath.length >= 1) {\r\n            let unit;\r\n            let unitPosition = 0;\r\n            do {\r\n                if (unitPosition == 0) {\r\n                    unit = this.root.get(fsUnitPath[unitPosition]);\r\n                }\r\n                else if (unit && unit instanceof FsDir_1.FsDir) {\r\n                    unit = unit.get(fsUnitPath[unitPosition]);\r\n                }\r\n                unitPosition++;\r\n            } while (unitPosition < fsUnitPath.length && unit);\r\n            if (unit == undefined) {\r\n                throw new Error('Unit undefined');\r\n            }\r\n            return unit;\r\n        }\r\n        else {\r\n            return this.root;\r\n        }\r\n    }\r\n}\r\nexports.FileSystemManager = FileSystemManager;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/fs/FileSystemManager.ts?");

/***/ }),

/***/ "./src/fs/FsDir.ts":
/*!*************************!*\
  !*** ./src/fs/FsDir.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FsDir = exports.FS_ROOT_NAME = void 0;\r\nconst FsFile_1 = __webpack_require__(/*! ./FsFile */ \"./src/fs/FsFile.ts\");\r\nexports.FS_ROOT_NAME = ':';\r\n;\r\nclass FsDir {\r\n    constructor(name) {\r\n        this._name = name;\r\n        this.content = new Array();\r\n        this.lastmod = new Date();\r\n        this._type = \"DIR\" /* DIR */;\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get size() {\r\n        let allSize = 0;\r\n        this.content.forEach(item => {\r\n            allSize += item.size;\r\n        });\r\n        this._size = allSize;\r\n        return this._size;\r\n    }\r\n    get parentDir() {\r\n        return this._parentDir;\r\n    }\r\n    add(fsUnit) {\r\n        if (fsUnit instanceof FsFile_1.FsFile) {\r\n            fsUnit.setParentDir(this);\r\n        }\r\n        else {\r\n            fsUnit._parentDir = this;\r\n        }\r\n        this.content.push(fsUnit);\r\n    }\r\n    removeThisDir(unit) {\r\n        unit.parentDir.content.splice(unit.parentDir.content.indexOf(unit), 1);\r\n    }\r\n    remove(unit) {\r\n        this.content.splice(this.content.indexOf(unit), 1);\r\n    }\r\n    get(name) {\r\n        for (const item of this.content) {\r\n            if (item.name == name) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n    checkUnit(fsUnit, type) {\r\n        for (const item of this.content) {\r\n            if (item.name == fsUnit && item.type == type) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    updateLastMode() {\r\n        this.lastmod = new Date();\r\n    }\r\n}\r\nexports.FsDir = FsDir;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/fs/FsDir.ts?");

/***/ }),

/***/ "./src/fs/FsFile.ts":
/*!**************************!*\
  !*** ./src/fs/FsFile.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FsFile = void 0;\r\nclass FsFile {\r\n    constructor(name, content) {\r\n        this._name = name;\r\n        this._content = content;\r\n        this.setSize(content);\r\n        this.lastmod = new Date();\r\n        this._type = \"FILE\" /* FILE */;\r\n    }\r\n    setSize(content) {\r\n        try {\r\n            this._size = new Blob([content]).size;\r\n        }\r\n        catch (error) {\r\n            this._size = Buffer.byteLength(content, 'utf-8');\r\n        }\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get content() {\r\n        return this._content;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    setContent(content) {\r\n        this._content = content;\r\n        this.setSize(this._content);\r\n    }\r\n    concatContent(content) {\r\n        const str = this._content.concat(content);\r\n        this._content = str;\r\n        this.setSize(this._content);\r\n    }\r\n    updateLastMode(param) {\r\n        if (param) {\r\n            this.lastmod = new Date(param);\r\n        }\r\n        else {\r\n            this.lastmod = new Date();\r\n        }\r\n    }\r\n    setParentDir(parrentDir) {\r\n        this._parentDir = parrentDir;\r\n    }\r\n}\r\nexports.FsFile = FsFile;\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/fs/FsFile.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst FileSystemManager_1 = __webpack_require__(/*! ./fs/FileSystemManager */ \"./src/fs/FileSystemManager.ts\");\r\nconst FsFile_1 = __webpack_require__(/*! ./fs/FsFile */ \"./src/fs/FsFile.ts\");\r\nconst Parser_1 = __webpack_require__(/*! ./Parser */ \"./src/Parser.ts\");\r\nconst Terminal_1 = __webpack_require__(/*! ./Terminal */ \"./src/Terminal.ts\");\r\nconst FsDir_1 = __webpack_require__(/*! ./fs/FsDir */ \"./src/fs/FsDir.ts\");\r\n__webpack_require__(/*! ./style/style.css */ \"./src/style/style.css\");\r\nvar initialFilesystem = new FileSystemManager_1.FileSystemManager();\r\ninitialFilesystem.addUnit([], new FsFile_1.FsFile('help.txt', 'cd [DIR] - changes the current folder.\\n' +\r\n    'mkdir [OPTION] [DIR]... - creates a directory.\\n' +\r\n    'rmdir [OPTION] [DIR] - removes a directory if it is empty.\\n' +\r\n    'touch [OPTION]... [FILE]... - creates a file.\\n' +\r\n    'pwd - shows the path to the current directory.\\n' +\r\n    'rm [OPTION]... [FILE]... - removes directory or file.\\n' +\r\n    'ls [OPTION]... [DIR] - shows directory contents.\\n' +\r\n    'cat [OPTION]... [FILE]... - print the contents of FILE (s) to standard output.\\n' +\r\n    'echo [STRING] - print a string to standard output.\\n' +\r\n    'clear - clears the window'));\r\ninitialFilesystem.addUnit([], new FsDir_1.FsDir('programs'));\r\ninitialFilesystem.addUnit([], new FsDir_1.FsDir('Downloads'));\r\ninitialFilesystem.addUnit([], new FsDir_1.FsDir('uni_study'));\r\ninitialFilesystem.addUnit(['programs'], new FsDir_1.FsDir('dir1'));\r\ninitialFilesystem.addUnit(['programs'], new FsFile_1.FsFile('doc.txt', '     '));\r\nvar terminal = new Terminal_1.Terminal(initialFilesystem);\r\nlet cmd = 'touch file.txt';\r\nconst elem = Parser_1.Parser.parse(cmd);\r\nterminal.runCommand(elem);\r\n\n\n//# sourceURL=webpack://terminal-ui/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
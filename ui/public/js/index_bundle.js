/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/Parser.js":
/*!************************!*\
  !*** ./dist/Parser.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Pair = exports.Parser = void 0;\r\nclass Parser {\r\n    static parsePath(path) {\r\n        let position = 0;\r\n        const pathTo = [];\r\n        while (position < path.length) {\r\n            pathTo[position] = path[position].split('/');\r\n            position++;\r\n        }\r\n        return pathTo;\r\n    }\r\n    static parse(line) {\r\n        const args = [];\r\n        const elems = [];\r\n        const kw = /\\s*(cd|mkdir|rmdir|touch|rm|ls|pwd|cat|echo|help)\\s*/;\r\n        const flags = /\\s*-(p|d|r|f|v|c|Q|1|s|S|t|l|E|n|b)+\\s*/g;\r\n        const text = /\\s*('[^\\']+')\\s*/;\r\n        const path = /\\s*([A-Za-z\\.\\-][A-Za-z0-9_\\-\\.]*\\/?)+\\s*/g;\r\n        const re = /[^>]*/;\r\n        let str = line;\r\n        let otherStr = '';\r\n        const index = line.indexOf('>');\r\n        if (index != -1) {\r\n            str = line.slice(0, index);\r\n            otherStr = line.slice(index);\r\n        }\r\n        let elem = str.match(kw);\r\n        if ((elem == null)) {\r\n            throw new Error('Bad command');\r\n        }\r\n        args.push(elem[0].trim());\r\n        str = str.replace(kw, '');\r\n        elem = str.match(flags);\r\n        if (elem != null) {\r\n            for (let i = 0; i < elem.length; i++) {\r\n                elem[i] = elem[i].trim();\r\n            }\r\n            let flagsElem = elem.join('');\r\n            flagsElem = '-' + flagsElem.split('-').join('');\r\n            args.push(flagsElem);\r\n            str = str.replace(flags, '');\r\n        }\r\n        else {\r\n            args.push('-');\r\n        }\r\n        if (args[0] == 'echo') {\r\n            elem = str.match(re);\r\n            if (elem == null) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            args.push(elem[0].trim());\r\n            str = str.replace(re, '');\r\n        }\r\n        else {\r\n            elem = str.match(text);\r\n            if (elem != null) {\r\n                args.push(elem[0]);\r\n                str = str.replace(text, '');\r\n            }\r\n            elem = str.match(path);\r\n            if (elem != null) {\r\n                let string = elem.join('');\r\n                string = string.trim();\r\n                args.push(string);\r\n                str = str.replace(path, '');\r\n            }\r\n        }\r\n        if (str != '') {\r\n            throw new Error('Invalid input');\r\n        }\r\n        if (otherStr != '') {\r\n            elems.push(...otherStr.split(' '));\r\n            if (elems.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            for (let i = 0; i < 2; i++) {\r\n                elems[i] = elems[i].trim();\r\n            }\r\n        }\r\n        return new Pair(args, elems);\r\n    }\r\n    static parseFlags(args, supportedFlagsList) {\r\n        return new Set(args\r\n            .filter(option => option.indexOf('-') === 0)\r\n            .map(option => option.replace('-', ''))\r\n            .join('')\r\n            .split('')\r\n            .filter(option => supportedFlagsList.includes(option)));\r\n    }\r\n}\r\nexports.Parser = Parser;\r\nclass Pair {\r\n    constructor(elem1, elem2) {\r\n        this.elem1 = elem1;\r\n        this.elem2 = elem2;\r\n    }\r\n    getElem1() {\r\n        return this.elem1;\r\n    }\r\n    getElem2() {\r\n        return this.elem2;\r\n    }\r\n}\r\nexports.Pair = Pair;\r\n//# sourceMappingURL=Parser.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/Parser.js?");

/***/ }),

/***/ "./dist/Terminal.js":
/*!**************************!*\
  !*** ./dist/Terminal.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Terminal = void 0;\r\nconst FileSystemClient_1 = __webpack_require__(/*! ./fs/FileSystemClient */ \"./dist/fs/FileSystemClient.js\");\r\nconst Parser_1 = __webpack_require__(/*! ./Parser */ \"./dist/Parser.js\");\r\nclass Terminal {\r\n    constructor(fileSystem) {\r\n        this.client = new FileSystemClient_1.FileSystemClient(fileSystem);\r\n    }\r\n    runCommand(args) {\r\n        var _a;\r\n        const cmd = args.getElem1();\r\n        const additionalArg = args.getElem2();\r\n        const commandName = cmd[0];\r\n        let str;\r\n        if (commandName == 'cd') {\r\n            if (cmd.length == 3) {\r\n                const lastIndex = cmd.length - 1;\r\n                const path = cmd[lastIndex].split('/');\r\n                this.client.cd(path);\r\n            }\r\n            else if (cmd.length == 2) {\r\n                this.client.cd([]);\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'mkdir') {\r\n            if (cmd.length != 3) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['p']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split(' ');\r\n            this.client.mkdir(path, flags);\r\n        }\r\n        else if (commandName == 'echo') {\r\n            if (cmd.length != 3) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const content = this.client.echo(cmd[2]);\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), content);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else {\r\n                str = content;\r\n                console.log(str);\r\n            }\r\n        }\r\n        else if (commandName == 'rmdir') {\r\n            if (cmd.length != 3) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['p']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split('/');\r\n            this.client.rmdir(path, flags);\r\n        }\r\n        else if (commandName == 'touch') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['c', 'd', 'r']);\r\n            const lastIndex = cmd.length - 1;\r\n            const path = cmd[lastIndex].split(' ');\r\n            if (cmd.length == 3) {\r\n                this.client.touch(path, flags);\r\n            }\r\n            else if (cmd.length == 4) {\r\n                const param = cmd[2];\r\n                this.client.touch(path, flags, param);\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'ls') {\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['1', 'l', 'Q', 't', 's', 'S']);\r\n            if (cmd.length == 2) {\r\n                str = this.client.ls(flags).join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n            }\r\n            else if (cmd.length == 3) {\r\n                const path = cmd[2].split('/');\r\n                str = this.client.ls(flags, path).join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid input');\r\n            }\r\n        }\r\n        else if (commandName == 'pwd') {\r\n            if (cmd.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            str = this.client.pwd();\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n        }\r\n        else if (commandName == 'rm') {\r\n            if (cmd.length != 3) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['r', 'f', 'v', 'd']);\r\n            const path = cmd[2].split(' ');\r\n            str = (_a = this.client.rm(path, flags)) === null || _a === void 0 ? void 0 : _a.join('\\n');\r\n        }\r\n        else if (commandName == 'cat') {\r\n            if (cmd.length != 3) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            const flags = Parser_1.Parser.parseFlags(cmd, ['E', 'n', 'b']);\r\n            const path = cmd[2].split(' ');\r\n            str = this.client.cat(path, flags).join('\\n');\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n        }\r\n        else if (commandName == 'help') {\r\n            if (cmd.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            str = this.client.help().join('\\n');\r\n            if (additionalArg.length != 0) {\r\n                if (additionalArg[0] == '>>') {\r\n                    this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                }\r\n                else if (additionalArg[0] == '>') {\r\n                    this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    addWorkLine(terminal) {\r\n        let str = '';\r\n        if (this.client.pwd() == '/home') {\r\n            str = '/';\r\n        }\r\n        else {\r\n            str = this.client.pwd().slice(5);\r\n        }\r\n        // const newWorkLine = document.querySelector('.work__line:last-child')?.cloneNode(true);\r\n        const input = document.querySelector('[contenteditable=true]:last-child');\r\n        if (input) {\r\n            input.setAttribute('contenteditable', 'false');\r\n        }\r\n        // if (newWorkLine) {\r\n        //     terminal.appendChild(newWorkLine);\r\n        // }\r\n        // const path = document.querySelectorAll('.path');\r\n        // if (path != null) {\r\n        //     path[path.length - 1].innerHTML = '(' + str + ')$';\r\n        // }\r\n        const newWorkLine = document.createElement('div');\r\n        newWorkLine.className = \"work__line\";\r\n        newWorkLine.innerHTML = '<span class=\"initial__entry\">guest:</span>' + '<span class=\"path\">' + '(' + str + ')' + '$' + '</span>' +\r\n            '<span id=\"input\" contenteditable=\"true\" class=\"input\" autocorrect=\"off\" autocapitalize=\"none\" autocomplete=\"off\"></span>';\r\n        terminal.appendChild(newWorkLine);\r\n        // const newInput = newWorkLine.querySelector('#input');\r\n        // if (newInput != null) {\r\n        //     newInput.innerHTML = ' ';\r\n        //     newInput.focus()\r\n        // }       \r\n    }\r\n    CommandOutput(line, terminal) {\r\n        let output;\r\n        try {\r\n            output = this.runCommand(Parser_1.Parser.parse(line));\r\n        }\r\n        catch (error) {\r\n            output = error.message;\r\n        }\r\n        if (output) {\r\n            const outputCommand = output.split('\\n');\r\n            for (const item of outputCommand) {\r\n                let div = document.createElement('div');\r\n                div.innerHTML = item;\r\n                terminal.appendChild(div);\r\n            }\r\n        }\r\n    }\r\n    sendCommand(body) {\r\n        const terminal = document.getElementById('terminal');\r\n        if (terminal == null) {\r\n            return;\r\n        }\r\n        let commandInput;\r\n        body.addEventListener('keypress', (event) => {\r\n            var _a;\r\n            const input = document.querySelector('[contenteditable=true]:last-child');\r\n            if (event.code != 'Enter')\r\n                return;\r\n            if (input != null) {\r\n                commandInput = (_a = input.textContent) === null || _a === void 0 ? void 0 : _a.trim();\r\n            }\r\n            if (!commandInput || commandInput == '') {\r\n                this.addWorkLine(terminal);\r\n            }\r\n            else {\r\n                this.CommandOutput(commandInput, terminal);\r\n                this.addWorkLine(terminal);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.Terminal = Terminal;\r\n//# sourceMappingURL=Terminal.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/Terminal.js?");

/***/ }),

/***/ "./dist/fs/FileSystemClient.js":
/*!*************************************!*\
  !*** ./dist/fs/FileSystemClient.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FileSystemClient = void 0;\r\nconst FsDir_1 = __webpack_require__(/*! ./FsDir */ \"./dist/fs/FsDir.js\");\r\nconst FsFile_1 = __webpack_require__(/*! ./FsFile */ \"./dist/fs/FsFile.js\");\r\nconst Parser_1 = __webpack_require__(/*! ../Parser */ \"./dist/Parser.js\");\r\n;\r\nclass FileSystemClient {\r\n    constructor(home) {\r\n        this.home = home;\r\n        this.pointer = home.getRoot();\r\n    }\r\n    cd(pathTo) {\r\n        const currentDir = this.pointer;\r\n        if (pathTo.length > 0) {\r\n            if (pathTo.length == 1 && pathTo[0] == '-') {\r\n                this.pointer = this.home.historyDir.getOldPointer();\r\n            }\r\n            else {\r\n                let childDir;\r\n                let position = 0;\r\n                do {\r\n                    if (pathTo[position] == '..') {\r\n                        if (this.pointer == this.home.getRoot()) {\r\n                            this.pointer == this.home.getRoot();\r\n                        }\r\n                        else {\r\n                            this.pointer = this.pointer.parentDir;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (pathTo[position] == 'home' && position == 0) {\r\n                            this.pointer = this.home.getRoot();\r\n                        }\r\n                        else {\r\n                            childDir = this.pointer.get(pathTo[position]);\r\n                            if (!childDir) {\r\n                                this.pointer = currentDir;\r\n                                throw new Error(`${pathTo.join('/')} not found`);\r\n                            }\r\n                            if (!(childDir instanceof FsDir_1.FsDir)) {\r\n                                this.pointer = currentDir;\r\n                                throw new Error(`${pathTo.join('/')} is not a directory`);\r\n                            }\r\n                            this.pointer = childDir;\r\n                        }\r\n                    }\r\n                    position++;\r\n                } while (position < pathTo.length);\r\n            }\r\n        }\r\n        else {\r\n            this.pointer = this.home.getRoot();\r\n        }\r\n        this.home.historyDir.add(this.pointer);\r\n        return true;\r\n    }\r\n    mkdir(path, flags) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        let elem = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    this.addDir(pathTo[position][0]);\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem));\r\n                    this.addDir(pathTo[position][indexElem]);\r\n                }\r\n                this.pointer = currentDir;\r\n                position++;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'p') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    while (elem < pathTo[position].length) {\r\n                        const childDir = this.addDir(pathTo[position][elem]);\r\n                        this.pointer = childDir;\r\n                        elem++;\r\n                    }\r\n                    this.pointer = currentDir;\r\n                    position++;\r\n                    elem = 0;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    rmdir(pathTo, flags) {\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            this.cd(pathTo.slice(0, pathTo.length));\r\n            if (this.pointer.content.length == 0) {\r\n                this.pointer.parentDir.removeThisDir(this.pointer);\r\n            }\r\n            else {\r\n                throw new Error('Directory must be empty');\r\n            }\r\n            this.pointer = currentDir;\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'p') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    this.cd(pathTo.slice(0, pathTo.length - position));\r\n                    if (this.pointer.content.length == 0) {\r\n                        this.pointer.parentDir.removeThisDir(this.pointer);\r\n                    }\r\n                    else {\r\n                        throw new Error('Directory must be empty');\r\n                    }\r\n                    this.pointer = currentDir;\r\n                    position++;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    touch(path, flags, param) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        if ((param && !this.hasAll(flags, 'd')) || (!param && this.hasAll(flags, 'd'))) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0 || (this.hasAll(flags, 'c') && flags.size == 1)) {\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    this.createFile(pathTo[position][0], this.hasAll(flags, 'c'));\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem));\r\n                    this.createFile(pathTo[position][indexElem], this.hasAll(flags, 'c'));\r\n                }\r\n                position++;\r\n                this.pointer = currentDir;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'd')) {\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.createFile(pathTo[position][0], this.hasAll(flags, 'c'), param);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.createFile(pathTo[position][indexElem], this.hasAll(flags, 'c'), param);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'r')) {\r\n                if (pathTo.length != 2) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                if (pathTo[0].length == 1) {\r\n                    const file1 = this.getFile(pathTo[0][0]);\r\n                    if (pathTo[1].length == 1) {\r\n                        this.pushLastMode(pathTo[1][0], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[1].length - 1;\r\n                        this.cd(pathTo[1].slice(0, indexElem));\r\n                        this.pushLastMode(pathTo[1][indexElem], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[0].length - 1;\r\n                    this.cd(pathTo[0].slice(0, indexElem));\r\n                    const file1 = this.getFile(pathTo[0][indexElem]);\r\n                    this.pointer = currentDir;\r\n                    if (pathTo[1].length == 1) {\r\n                        this.pushLastMode(pathTo[1][0], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[1].length - 1;\r\n                        this.cd(pathTo[1].slice(0, indexElem));\r\n                        this.pushLastMode(pathTo[1][indexElem], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                }\r\n                this.pointer = currentDir;\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    pwd() {\r\n        const elemOfPath = [];\r\n        const currentDir = this.pointer;\r\n        while (this.pointer != this.home.getRoot()) {\r\n            elemOfPath.push(this.pointer.name);\r\n            this.pointer = this.pointer.parentDir;\r\n        }\r\n        this.pointer = currentDir;\r\n        elemOfPath.push('home');\r\n        const path = '/' + elemOfPath.reverse().join('/');\r\n        console.log(path);\r\n        return path;\r\n    }\r\n    rm(path, flags) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            const str = [];\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                    this.messageErrorFile(pathTo[position][0], elemDel);\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem));\r\n                    const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                    this.messageErrorFile(pathTo[position][indexElem], elemDel);\r\n                }\r\n                position++;\r\n                this.pointer = currentDir;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'r', 'f', 'v') && flags.size == 3) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteDir(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.deleteDir(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'v') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteDir(pathTo[position][0], str);\r\n                        this.messageErrorDir(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteDir(pathTo[position][indexElem], str);\r\n                        this.messageErrorDir(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'f') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteDir(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.deleteDir(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'v', 'f') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][0], str);\r\n                        }\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][indexElem], str);\r\n                        }\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'r') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteDir(pathTo[position][0], str);\r\n                        this.messageErrorDir(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteDir(pathTo[position][indexElem], str);\r\n                        this.messageErrorDir(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'v') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][0], str);\r\n                        }\r\n                        this.messageError(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][indexElem], str);\r\n                        }\r\n                        this.messageError(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                for (let i = 0; i < str.length; i++) {\r\n                    str[i] = 'removed ' + str[i];\r\n                }\r\n                str.map(item => {\r\n                    console.log(item);\r\n                });\r\n                return str;\r\n            }\r\n            else if (this.hasAll(flags, 'f') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteFile(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.deleteFile(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'd') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    this.rmdir(pathTo[position], new Set([]));\r\n                    position++;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n    }\r\n    ls(flags, pathTo) {\r\n        const elems = [];\r\n        const str = [];\r\n        const currentDir = this.pointer;\r\n        if (pathTo) {\r\n            this.cd(pathTo);\r\n        }\r\n        this.pointer.content.map(item => {\r\n            elems.push(item);\r\n            str.push(item.name);\r\n        });\r\n        if (this.hasAll(flags, 'Q')) {\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = '\"' + str[i] + '\"';\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'S')) {\r\n            for (let i = 0; i < elems.length - 1; i++) {\r\n                for (let j = i + 1; j < elems.length; j++) {\r\n                    if (elems[i].size < elems[j].size) {\r\n                        this.swap(elems, i, j);\r\n                        this.swap(str, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 't')) {\r\n            for (let i = 0; i < elems.length - 1; i++) {\r\n                for (let j = i + 1; j < elems.length; j++) {\r\n                    if (elems[i].lastmod < elems[j].lastmod) {\r\n                        this.swap(elems, i, j);\r\n                        this.swap(str, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'l')) {\r\n            let sum = 0;\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (elems[i] instanceof FsFile_1.FsFile) {\r\n                    sum += elems[i].size;\r\n                }\r\n                str[i] = this.collectString(elems[i]) + str[i];\r\n            }\r\n            str.push('total ' + sum);\r\n        }\r\n        if (this.hasAll(flags, 's')) {\r\n            let sum = 0;\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (elems[i] instanceof FsFile_1.FsFile) {\r\n                    str[i] = elems[i].size.toString() + ' ' + str[i];\r\n                    sum += elems[i].size;\r\n                }\r\n                else {\r\n                    str[i] = '0 ' + str[i];\r\n                }\r\n            }\r\n            if (!(str.includes('total ' + sum))) {\r\n                str.push('total ' + sum);\r\n            }\r\n        }\r\n        if (str.length > elems.length) {\r\n            const sumElem = str.pop();\r\n            if (sumElem) {\r\n                str.unshift(sumElem);\r\n            }\r\n        }\r\n        str.map(item => {\r\n            console.log(item);\r\n        });\r\n        this.pointer = currentDir;\r\n        return str;\r\n    }\r\n    cat(source, flags) {\r\n        const sourcePath = Parser_1.Parser.parsePath(source);\r\n        const currentDir = this.pointer;\r\n        let str = [];\r\n        let position = 0;\r\n        if (sourcePath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        while (position < sourcePath.length) {\r\n            this.getContentInSourceFile(sourcePath, str, position);\r\n            this.pointer = currentDir;\r\n            position++;\r\n        }\r\n        if (this.hasAll(flags, 'E')) {\r\n            const fullContent = str.join('\\n');\r\n            str = fullContent.split('\\n');\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = str[i] + '$';\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'n')) {\r\n            const fullContent = str.join('\\n');\r\n            str = fullContent.split('\\n');\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = '\\t' + (i + 1) + ' ' + str[i];\r\n            }\r\n        }\r\n        else if (this.hasAll(flags, 'b')) {\r\n            const fullContent = str.join('\\n');\r\n            str = fullContent.split('\\n');\r\n            let counter = 1;\r\n            for (let i = 0; i < str.length; i++) {\r\n                if (str[i] != '') {\r\n                    str[i] = '\\t' + counter + ' ' + str[i];\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n        console.log(str.join('\\n'));\r\n        return str;\r\n    }\r\n    echo(content) {\r\n        return content;\r\n    }\r\n    setOutputInTargetFile(targetPath, content) {\r\n        if (targetPath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        const currentDir = this.pointer;\r\n        this.putInTargetFile(targetPath, content, 1);\r\n        this.pointer = currentDir;\r\n    }\r\n    cancateOutputInTargetFile(targetPath, content) {\r\n        if (targetPath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        const currentDir = this.pointer;\r\n        this.putInTargetFile(targetPath, content, 2);\r\n        this.pointer = currentDir;\r\n    }\r\n    help() {\r\n        const str = [\r\n            \"cd [DIR] - changes the current folder.\" /* CD */,\r\n            \"mkdir [OPTION] [DIR] - creates a directory.\" /* MKDIR */,\r\n            \"rmdir [OPTION] [DIR] - removes a directory if it is empty.\" /* RMDIR */,\r\n            \"touch [OPTION]... [FILE]... - creates a file.\" /* TOUCH */,\r\n            \"pwd - shows the path to the current directory.\" /* PWD */,\r\n            \"rm [OPTION]... [FILE]... - removes directory or file.\" /* RM */,\r\n            \"ls [OPTION]... [DIR] - shows directory contents.\" /* LS */,\r\n            \"cat [OPTION]... [FILE]... - print the contents of FILE (s) to standard output.\" /* CAT */,\r\n            \"echo [STRING] - print a string to standard output.\" /* ECHO */\r\n        ];\r\n        str.map(item => {\r\n            console.log(item);\r\n        });\r\n        return str;\r\n    }\r\n    getContentInSourceFile(source, str, index) {\r\n        if (source[index].length == 1) {\r\n            this.getContentFile(source[index][0], str);\r\n        }\r\n        else {\r\n            const indexElem = source[index].length - 1;\r\n            this.cd(source[index].slice(0, indexElem));\r\n            this.getContentFile(source[index][indexElem], str);\r\n        }\r\n    }\r\n    putInTargetFile(target, content, counter) {\r\n        if (target.length == 1) {\r\n            this.pushContentFile(target[0], content, counter);\r\n        }\r\n        else {\r\n            const indexElem = target.length - 1;\r\n            this.cd(target.slice(0, indexElem));\r\n            this.pushContentFile(target[indexElem], content, counter);\r\n        }\r\n    }\r\n    pushContentFile(path, str, counter) {\r\n        this.touch([path], new Set([]));\r\n        const file = this.pointer.get(path);\r\n        if (file instanceof FsFile_1.FsFile) {\r\n            if (counter == 1) {\r\n                file.setContent(str);\r\n            }\r\n            if (counter == 2) {\r\n                file.concatContent('\\n' + str);\r\n            }\r\n        }\r\n        this.messageErrorFile(path, file);\r\n    }\r\n    getContentFile(path, str) {\r\n        const file = this.pointer.get(path);\r\n        if (file instanceof FsFile_1.FsFile) {\r\n            str.push(file.content);\r\n        }\r\n        this.messageErrorFile(path, file);\r\n    }\r\n    collectString(elem) {\r\n        const str = elem.size + ' ' + this.getMonth(elem.lastmod.getMonth()) + ' ' + this.checkTime(elem.lastmod.getDate()) + ' ' + this.checkTime(elem.lastmod.getHours()) + ':' + this.checkTime(elem.lastmod.getMinutes()) + ' ';\r\n        return str;\r\n    }\r\n    checkTime(time) {\r\n        if (time < 10) {\r\n            return '0' + time;\r\n        }\r\n        return time;\r\n    }\r\n    hasAll(set, ...elems) {\r\n        for (const elem of elems) {\r\n            if (!set.has(elem)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    deleteFile(path, str) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (fileInp instanceof FsFile_1.FsFile) {\r\n            str.push(fileInp.name);\r\n            this.pointer.remove(fileInp);\r\n        }\r\n        return fileInp;\r\n    }\r\n    deleteDir(path, str) {\r\n        const dirInp = this.pointer.get(path);\r\n        if (dirInp instanceof FsDir_1.FsDir) {\r\n            str.push(...this.removeAll(dirInp));\r\n        }\r\n        return dirInp;\r\n    }\r\n    messageErrorFile(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        if (elem instanceof FsDir_1.FsDir) {\r\n            throw new Error(`${path} is directory`);\r\n        }\r\n    }\r\n    messageErrorDir(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        if (elem instanceof FsFile_1.FsFile) {\r\n            throw new Error(`${path} is file`);\r\n        }\r\n    }\r\n    messageError(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n    }\r\n    createFile(path, availability, param) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (!(fileInp instanceof FsFile_1.FsFile) && !availability) {\r\n            const file = new FsFile_1.FsFile(path, '');\r\n            file.updateLastMode(param);\r\n            this.pointer.add(file);\r\n        }\r\n        else if (fileInp instanceof FsFile_1.FsFile) {\r\n            fileInp.updateLastMode(param);\r\n        }\r\n    }\r\n    pushLastMode(path, file, availability) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (!(fileInp instanceof FsFile_1.FsFile) && !availability) {\r\n            const file2 = new FsFile_1.FsFile(path, '');\r\n            file2.lastmod = file.lastmod;\r\n            this.pointer.add(file2);\r\n        }\r\n        else if (fileInp instanceof FsFile_1.FsFile) {\r\n            fileInp.lastmod = file.lastmod;\r\n        }\r\n    }\r\n    getFile(path) {\r\n        const file1 = this.pointer.get(path);\r\n        if (!(file1 instanceof FsFile_1.FsFile)) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        return file1;\r\n    }\r\n    removeAll(dir) {\r\n        const str = [];\r\n        while (dir.content.length > 0) {\r\n            const elem = dir.content.pop();\r\n            if (elem) {\r\n                str.push(elem.name);\r\n            }\r\n            if (elem instanceof FsDir_1.FsDir) {\r\n                str.push(...this.removeAll(elem));\r\n            }\r\n        }\r\n        if (dir.parentDir.get(dir.name)) {\r\n            dir.parentDir.content.splice(dir.parentDir.content.indexOf(dir), 1);\r\n            str.push(dir.name);\r\n        }\r\n        return str;\r\n    }\r\n    addDir(path) {\r\n        if (!(this.pointer.checkUnit(path, \"DIR\" /* DIR */))) {\r\n            throw new Error('Directory already exists');\r\n        }\r\n        const childDir = new FsDir_1.FsDir(path);\r\n        this.pointer.add(childDir);\r\n        return childDir;\r\n    }\r\n    swap(array, i, j) {\r\n        const tmp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = tmp;\r\n    }\r\n    getMonth(index) {\r\n        let month;\r\n        switch (index) {\r\n            case 0: {\r\n                month = 'Jan';\r\n                break;\r\n            }\r\n            case 1: {\r\n                month = 'Feb';\r\n                break;\r\n            }\r\n            case 2: {\r\n                month = 'Mar';\r\n                break;\r\n            }\r\n            case 3: {\r\n                month = 'Apr';\r\n                break;\r\n            }\r\n            case 4: {\r\n                month = 'May';\r\n                break;\r\n            }\r\n            case 5: {\r\n                month = 'Jun';\r\n                break;\r\n            }\r\n            case 6: {\r\n                month = 'Jul';\r\n                break;\r\n            }\r\n            case 7: {\r\n                month = 'Aug';\r\n                break;\r\n            }\r\n            case 8: {\r\n                month = 'Sept';\r\n                break;\r\n            }\r\n            case 9: {\r\n                month = 'Oct';\r\n                break;\r\n            }\r\n            case 10: {\r\n                month = 'Nov';\r\n                break;\r\n            }\r\n            case 11: {\r\n                month = 'Dec';\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error('error');\r\n            }\r\n        }\r\n        return month;\r\n    }\r\n}\r\nexports.FileSystemClient = FileSystemClient;\r\n//# sourceMappingURL=FileSystemClient.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FileSystemClient.js?");

/***/ }),

/***/ "./dist/fs/FileSystemManager.js":
/*!**************************************!*\
  !*** ./dist/fs/FileSystemManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FileSystemManager = void 0;\r\nconst FsDir_1 = __webpack_require__(/*! ./FsDir */ \"./dist/fs/FsDir.js\");\r\nclass FileSystemManager {\r\n    constructor() {\r\n        this.root = new FsDir_1.FsDir(FsDir_1.FS_ROOT_NAME);\r\n        this.historyDir = new Pair();\r\n        this.historyDir.add(this.root);\r\n        this.fileSystem = new Map();\r\n        this.fileSystem.set(this.root, this.root.content);\r\n    }\r\n    getRoot() {\r\n        return this.root;\r\n    }\r\n    printDir(path) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        const arrayContent = this.fileSystem.get(parentDir);\r\n        if (arrayContent) {\r\n            for (const item of arrayContent) {\r\n                console.log(item);\r\n            }\r\n        }\r\n    }\r\n    getSizeDir(path) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        return parentDir.size;\r\n    }\r\n    addUnit(path, unit) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        // if (!(parentDir.checkUnit(unit))) {\r\n        //     throw new Error('Element already exists');\r\n        // }\r\n        parentDir.add(unit);\r\n        if (unit instanceof FsDir_1.FsDir) {\r\n            this.fileSystem.set(unit, unit.content);\r\n        }\r\n        return true;\r\n    }\r\n    removeUnit(path, unit) {\r\n        const parentDir = this.get(path);\r\n        if (!parentDir) {\r\n            throw new Error('Unit not exists');\r\n        }\r\n        if (!(parentDir instanceof FsDir_1.FsDir)) {\r\n            throw new Error('Should be directory');\r\n        }\r\n        // if (parentDir.checkUnit(unit)) {\r\n        //     throw new Error('Element not found');\r\n        // }\r\n        parentDir.content.splice(parentDir.content.indexOf(unit), 1);\r\n        if (unit instanceof FsDir_1.FsDir) {\r\n            this.fileSystem.delete(unit);\r\n        }\r\n        return true;\r\n    }\r\n    get(fsUnitPath) {\r\n        if (fsUnitPath.length >= 1) {\r\n            let unit;\r\n            let unitPosition = 0;\r\n            do {\r\n                if (unitPosition == 0) {\r\n                    unit = this.root.get(fsUnitPath[unitPosition]);\r\n                }\r\n                else if (unit && unit instanceof FsDir_1.FsDir) {\r\n                    unit = unit.get(fsUnitPath[unitPosition]);\r\n                }\r\n                unitPosition++;\r\n            } while (unitPosition < fsUnitPath.length && unit);\r\n            if (unit == undefined) {\r\n                throw new Error('Unit undefined');\r\n            }\r\n            return unit;\r\n        }\r\n        else {\r\n            return this.root;\r\n        }\r\n    }\r\n}\r\nexports.FileSystemManager = FileSystemManager;\r\nclass Pair {\r\n    constructor() {\r\n        this.data = [];\r\n        this.lastAddIndex = 0;\r\n    }\r\n    add(item) {\r\n        if (this.lastAddIndex > 1) {\r\n            this.lastAddIndex = 1;\r\n            this.data[0] = this.data[1];\r\n        }\r\n        this.data[this.lastAddIndex] = item;\r\n        this.lastAddIndex++;\r\n    }\r\n    getOldPointer() {\r\n        return this.data[0];\r\n    }\r\n    list() {\r\n        return this.data;\r\n    }\r\n}\r\n//# sourceMappingURL=FileSystemManager.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FileSystemManager.js?");

/***/ }),

/***/ "./dist/fs/FsDir.js":
/*!**************************!*\
  !*** ./dist/fs/FsDir.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FsDir = exports.FS_ROOT_NAME = void 0;\r\nconst FsFile_1 = __webpack_require__(/*! ./FsFile */ \"./dist/fs/FsFile.js\");\r\nexports.FS_ROOT_NAME = ':';\r\n;\r\nclass FsDir {\r\n    constructor(name) {\r\n        this._name = name;\r\n        this.content = new Array();\r\n        this.lastmod = new Date();\r\n        this._type = \"DIR\" /* DIR */;\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get size() {\r\n        let allSize = 0;\r\n        this.content.forEach(item => {\r\n            allSize += item.size;\r\n        });\r\n        this._size = allSize;\r\n        return this._size;\r\n    }\r\n    get parentDir() {\r\n        return this._parentDir;\r\n    }\r\n    add(fsUnit) {\r\n        if (fsUnit instanceof FsFile_1.FsFile) {\r\n            fsUnit.setParentDir(this);\r\n        }\r\n        else {\r\n            fsUnit._parentDir = this;\r\n        }\r\n        this.content.push(fsUnit);\r\n    }\r\n    removeThisDir(unit) {\r\n        unit.parentDir.content.splice(unit.parentDir.content.indexOf(unit), 1);\r\n    }\r\n    remove(unit) {\r\n        this.content.splice(this.content.indexOf(unit), 1);\r\n    }\r\n    get(name) {\r\n        for (const item of this.content) {\r\n            if (item.name == name) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n    checkUnit(fsUnit, type) {\r\n        for (const item of this.content) {\r\n            if (item.name == fsUnit && item.type == type) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    updateLastMode() {\r\n        this.lastmod = new Date();\r\n    }\r\n}\r\nexports.FsDir = FsDir;\r\n//# sourceMappingURL=FsDir.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FsDir.js?");

/***/ }),

/***/ "./dist/fs/FsFile.js":
/*!***************************!*\
  !*** ./dist/fs/FsFile.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FsFile = void 0;\r\n;\r\nclass FsFile {\r\n    constructor(name, content) {\r\n        this._name = name;\r\n        this._content = content;\r\n        this.setSize(content);\r\n        this.lastmod = new Date();\r\n        this._type = \"FILE\" /* FILE */;\r\n    }\r\n    setSize(content) {\r\n        try {\r\n            this._size = new Blob([content]).size;\r\n        }\r\n        catch (error) {\r\n            this._size = Buffer.byteLength(content, 'utf-8');\r\n        }\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get content() {\r\n        return this._content;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    setContent(content) {\r\n        this._content = content;\r\n        this.setSize(this._content);\r\n    }\r\n    concatContent(content) {\r\n        const str = this._content.concat(content);\r\n        this._content = str;\r\n        this.setSize(this._content);\r\n    }\r\n    updateLastMode(param) {\r\n        if (param) {\r\n            this.lastmod = new Date(param);\r\n        }\r\n        else {\r\n            this.lastmod = new Date();\r\n        }\r\n    }\r\n    setParentDir(parrentDir) {\r\n        this._parentDir = parrentDir;\r\n    }\r\n}\r\nexports.FsFile = FsFile;\r\n//# sourceMappingURL=FsFile.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FsFile.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst FileSystemManager_1 = __webpack_require__(/*! ./fs/FileSystemManager */ \"./dist/fs/FileSystemManager.js\");\r\nconst FsFile_1 = __webpack_require__(/*! ./fs/FsFile */ \"./dist/fs/FsFile.js\");\r\nconst Parser_1 = __webpack_require__(/*! ./Parser */ \"./dist/Parser.js\");\r\nconst Terminal_1 = __webpack_require__(/*! ./Terminal */ \"./dist/Terminal.js\");\r\nvar initialFilesystem = new FileSystemManager_1.FileSystemManager();\r\ninitialFilesystem\r\n    .addUnit([], new FsFile_1.FsFile('tmp.txt', '123123123'));\r\n// initialFilesystem\r\n//   .addUnit([], new FsDir('NewDIR1'));\r\n// initialFilesystem\r\n//   .addUnit(['NewDIR'], new FsFile('more.txt', 'lalalala')); \r\n// initialFilesystem\r\n//   .addUnit(['NewDIR'], new FsDir('NewDIR2')); \r\n// initialFilesystem\r\n//   .addUnit(['NewDIR', 'NewDIR2'], new FsFile('more1.txt', 'lalalala')); \r\n// initialFilesystem.printDir([]);\r\n// initialFilesystem.printDir(['NewDIR']);\r\nvar terminal = new Terminal_1.Terminal(initialFilesystem);\r\nlet str = 'mkdir -p NewDIR1/NewDIR12/NewDIR123 NewDIR2/NewDIR21/NewDIR213';\r\nconst elems = Parser_1.Parser.parse(str);\r\n// let str2 = 'ls -l -Q >> file1.txt';\r\n// const elems2 = Parser.parse(str2);\r\n// const elems11 = Parser.parse('cat -n -E file1.txt')\r\n// let str3 = 'cd NewDIR1/NewDIR12';\r\n// const elems3 = Parser.parse(str3);\r\n// const elems10 = Parser.parse('ls -l > file1.txt')\r\n// const elems12 = Parser.parse('ls -l')\r\n// client.mkdir(['NewDIR1/NewDIR12/NewDIR123', 'NewDIR2/NewDIR21/NewDIR213'], flags);\r\nterminal.runCommand(elems);\r\n// terminal.runCommand(elems2);\r\n// terminal.runCommand(elems11);\r\n// terminal.runCommand(elems3);\r\n// terminal.runCommand(elems2);\r\n// terminal.runCommand(elems10);\r\n// terminal.runCommand(elems12);\r\n// terminal.runCommand(elems11);\r\nterminal.sendCommand(document.body);\r\n// const term = document.getElementById('terminal');\r\n// if (term != null) {\r\n//   terminal.addWorkLine(term)\r\n// } else {\r\n//   console.log('')\r\n// }\r\n// terminal.runCommand(elems3);\r\n// terminal.runCommand(elems4);\r\n// terminal.runCommand(elems2);\r\n// terminal.runCommand(elems5);\r\n// terminal.runCommand(elems6);\r\n// terminal.runCommand(elems8);\r\n// terminal.runCommand(elems2);\r\n// terminal.runCommand(elems7);\r\n// terminal.runCommand(elems2);\r\n// terminal.runCommand(elems9);\r\n// terminal.runCommand(elems10);\r\n// client.cd(['NewDIR1']);\r\n// client.touch(['file1.txt'], flags2, '04 Jan');\r\n// client.cat([['file1.txt']], ['NewDIR12', 'file2.txt'], flags1, 1);\r\n// client.cat([['NewDIR12', 'file2.txt'], ['file1.txt']], ['NewDIR12','NewDIR123', 'file3.txt'], flags1, 1);\r\n// client.cat([['NewDIR12','NewDIR123', 'file3.txt'], ['NewDIR12', 'file2.txt'], ['file1.txt']], ['file51.txt'], flags1, 1);\r\n// client.cat(['file1.txt'], flags4);\r\n// client.echo('123');\r\n// client.cat(['file1.txt'], flags4);\r\n// client.rm([['NewDIR12', 'NewDIR123'], ['NewDIR12'], ['file1.txt']], flags1);\r\n// client.touch([['NewDIR12', 'file2.txt'], ['file3.txt']], flags1);\r\n// client.rm([['file1.txt'], ['NewDIR12']], flags);\r\n// client.pwd();\r\n// client.printContent();\r\n// client.ls(flags3);\r\nconsole.log('end');\r\n// client.cd(['NewDIR12']);\r\n// client.printContent();\r\n// console.log('end')\r\n// client.touch([['NewDIR12', 'NewDIR123', 'file2.txt']], []);\r\n// client.touch([['NewDIR12', 'file1.txt'], ['NewDIR12', 'NewDIR123', 'file3.txt']], ['r', 'c'])\r\n// client.printContent();\r\n// console.log('end');\r\n// client.cd(['NewDIR12']);\r\n// client.printContent();\r\n// console.log('end');\r\n// client.cd(['NewDIR123']);\r\n// client.printContent();\r\n// console.log('end');\r\n// client.touch(['file1', 'file3'], ['r', 'c']);\r\n// client.pwd();\r\n// initialFilesystem\r\n//   .addUnit(['NewDIR1', 'NewDIR12'], new FsFile('more1.txt', 'lalalala')); \r\n// client.rmdir(['NewDIR1', 'NewDIR12', 'NewDIR123'],  '');\r\n// client.cd(['NewDIR1', 'NewDIR12', 'NewDIR123']);\r\n// client.cd([]);\r\n// client.cd(['NewDIR2', 'NewDIR21', \"NewDIR213\"]);\r\n// client.cd(['NewDIR2', '..']);\r\n// client.cd(['NewDIR', 'NewDIR2']);\r\n// client.cd(['..', '..', 'NewDIR']);\r\n// client.cd(['-']);\r\n// client.cd([]);\r\n// client.printContent();\r\n// client.cd(['NewDIR3']);\r\n// client.printContent();\r\n// client.printHistory();\r\n// console.log('321321321321321');\r\n// initialFilesystem.printDir(['NewDIR', 'NewDIR2']);\r\n// console.log(elems)\r\n// const line = 'echo 123 >> NewDIR1/file.txt';\r\n// const tmp = line.slice(0, line.indexOf('>'));\r\n// console.log(tmp)\r\n// const tmp2 = line.slice(line.indexOf('>'));\r\n// console.log(tmp2);\r\nconst line = ['ls', '-'];\r\nconsole.log(Parser_1.Parser.parseFlags(line, ['1', 'l', 'Q', 't', 's', 'S']));\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./dist/index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
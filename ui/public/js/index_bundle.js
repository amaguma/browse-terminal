/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/Parser.js":
/*!************************!*\
  !*** ./dist/Parser.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Pair = exports.Parser = void 0;\r\nclass Parser {\r\n    static parsePath(path) {\r\n        let position = 0;\r\n        const pathTo = [];\r\n        while (position < path.length) {\r\n            pathTo[position] = path[position].split('/');\r\n            position++;\r\n        }\r\n        return pathTo;\r\n    }\r\n    static parse(line) {\r\n        const args = [];\r\n        const elems = [];\r\n        const kw = /\\s*(cd|mkdir|rmdir|touch|rm|ls|pwd|cat|echo|help)\\s*/;\r\n        const flags = /\\s*-(p|d|r|f|v|c|Q|1|s|S|t|l|E|n|b)+\\s*/g;\r\n        const text = /\\s*('[^\\']+')\\s*/;\r\n        const path = /\\s*([A-Za-z][A-Za-z0-9_\\-\\.]*\\/?)+\\s*/g;\r\n        const re = /[^>]*/;\r\n        let str = line;\r\n        let otherStr = '';\r\n        const index = line.indexOf('>');\r\n        if (index != -1) {\r\n            str = line.slice(0, index);\r\n            otherStr = line.slice(index);\r\n        }\r\n        let elem = str.match(kw);\r\n        if ((elem == null)) {\r\n            throw new Error('Bad command');\r\n        }\r\n        args.push(elem[0].trim());\r\n        str = str.replace(kw, '');\r\n        elem = str.match(flags);\r\n        if (elem != null) {\r\n            for (let i = 0; i < elem.length; i++) {\r\n                elem[i] = elem[i].trim();\r\n            }\r\n            let flagsElem = elem.join('');\r\n            flagsElem = '-' + flagsElem.split('-').join('');\r\n            args.push(flagsElem);\r\n            str = str.replace(flags, '');\r\n        }\r\n        if (args[0] == 'echo') {\r\n            elem = str.match(re);\r\n            if (elem == null) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            args.push(elem[0].trim());\r\n            str = str.replace(re, '');\r\n        }\r\n        else {\r\n            elem = str.match(text);\r\n            if (elem != null) {\r\n                args.push(elem[0]);\r\n                str = str.replace(text, '');\r\n            }\r\n            elem = str.match(path);\r\n            if (elem != null) {\r\n                let string = elem.join('');\r\n                string = string.trim();\r\n                args.push(string);\r\n                str = str.replace(path, '');\r\n            }\r\n        }\r\n        if (str != '') {\r\n            throw new Error('Invalid input');\r\n        }\r\n        if (otherStr != '') {\r\n            elems.push(...otherStr.split(' '));\r\n            if (elems.length > 2) {\r\n                throw new Error('Invalid input');\r\n            }\r\n            for (let i = 0; i < 2; i++) {\r\n                elems[i] = elems[i].trim();\r\n            }\r\n        }\r\n        return new Pair(args, elems);\r\n    }\r\n    static parseFlags(args, supportedFlagsList) {\r\n        return new Set(args\r\n            .filter(option => option.indexOf('-') === 0)\r\n            .map(option => option.replace('-', ''))\r\n            .join('')\r\n            .split('')\r\n            .filter(option => supportedFlagsList.includes(option)));\r\n    }\r\n}\r\nexports.Parser = Parser;\r\nclass Pair {\r\n    constructor(elem1, elem2) {\r\n        this.elem1 = elem1;\r\n        this.elem2 = elem2;\r\n    }\r\n    getElem1() {\r\n        return this.elem1;\r\n    }\r\n    getElem2() {\r\n        return this.elem2;\r\n    }\r\n}\r\nexports.Pair = Pair;\r\n//# sourceMappingURL=Parser.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/Parser.js?");

/***/ }),

/***/ "./dist/Terminal.js":
/*!**************************!*\
  !*** ./dist/Terminal.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Terminal = void 0;\r\nconst FileSystemClient_1 = __webpack_require__(/*! ./fs/FileSystemClient */ \"./dist/fs/FileSystemClient.js\");\r\nconst Parser_1 = __webpack_require__(/*! ./Parser */ \"./dist/Parser.js\");\r\nclass Terminal {\r\n    constructor(fileSystem) {\r\n        this.client = new FileSystemClient_1.FileSystemClient(fileSystem);\r\n    }\r\n    runCommand(args) {\r\n        const cmd = args.getElem1();\r\n        const additionalArg = args.getElem2();\r\n        const commandName = cmd[0];\r\n        let str;\r\n        try {\r\n            if (commandName == 'cd') {\r\n                if (cmd.length != 2) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                const path = cmd[1].split('/');\r\n                this.client.cd(path);\r\n            }\r\n            else if (commandName == 'mkdir') {\r\n                if (cmd.length == 2 || cmd.length == 3) {\r\n                    const flags = Parser_1.Parser.parseFlags(cmd, ['p']);\r\n                    const lastIndex = cmd.length - 1;\r\n                    const path = cmd[lastIndex].split(' ');\r\n                    this.client.mkdir(path, flags);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else if (commandName == 'echo') {\r\n                if (cmd.length != 2) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                str = this.client.echo(cmd[1]);\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n                else {\r\n                    console.log(str);\r\n                }\r\n            }\r\n            else if (commandName == 'rmdir') {\r\n                if (cmd.length == 2 || cmd.length == 3) {\r\n                    const flags = Parser_1.Parser.parseFlags(cmd, ['p']);\r\n                    const lastIndex = cmd.length - 1;\r\n                    const path = cmd[lastIndex].split('/');\r\n                    this.client.mkdir(path, flags);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else if (commandName == 'touch') {\r\n                const flags = Parser_1.Parser.parseFlags(cmd, ['c', 'd', 'r']);\r\n                const lastIndex = cmd.length - 1;\r\n                const path = cmd[lastIndex].split(' ');\r\n                if (cmd.length == 2 || cmd.length == 3) {\r\n                    this.client.touch(path, flags);\r\n                }\r\n                else if (cmd.length == 4) {\r\n                    const param = cmd[2];\r\n                    this.client.touch(path, flags, param);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else if (commandName == 'ls') {\r\n                const flags = Parser_1.Parser.parseFlags(cmd, ['1', 'l', 'Q', 't', 's', 'S']);\r\n                if (cmd.length == 2) {\r\n                    str = this.client.ls(flags).join('\\n');\r\n                    if (additionalArg.length != 0) {\r\n                        if (additionalArg[0] == '>>') {\r\n                            this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                        }\r\n                        else if (additionalArg[0] == '>') {\r\n                            this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                        }\r\n                        else {\r\n                            throw new Error('Invalid input');\r\n                        }\r\n                    }\r\n                }\r\n                else if (cmd.length == 3) {\r\n                    const path = cmd[2].split('/');\r\n                    str = this.client.ls(flags, path).join('\\n');\r\n                    if (additionalArg.length != 0) {\r\n                        if (additionalArg[0] == '>>') {\r\n                            this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                        }\r\n                        else if (additionalArg[0] == '>') {\r\n                            this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                        }\r\n                        else {\r\n                            throw new Error('Invalid input');\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n            else if (commandName == 'pwd') {\r\n                if (cmd.length > 1) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                str = this.client.pwd();\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n            }\r\n            else if (commandName == 'rm') {\r\n                if (cmd.length != 3) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                const flags = Parser_1.Parser.parseFlags(cmd, ['r', 'f', 'v', 'd']);\r\n                const path = cmd[2].split(' ');\r\n                this.client.rm(path, flags);\r\n            }\r\n            else if (commandName == 'cat') {\r\n                if (cmd.length != 3) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                const flags = Parser_1.Parser.parseFlags(cmd, ['E', 'n', 'b']);\r\n                const path = cmd[2].split(' ');\r\n                str = this.client.cat(path, flags).join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n            }\r\n            else if (commandName == 'help') {\r\n                if (cmd.length > 1) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                str = this.client.help().join('\\n');\r\n                if (additionalArg.length != 0) {\r\n                    if (additionalArg[0] == '>>') {\r\n                        this.client.cancateOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else if (additionalArg[0] == '>') {\r\n                        this.client.setOutputInTargetFile(additionalArg[1].split('/'), str);\r\n                    }\r\n                    else {\r\n                        throw new Error('Invalid input');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            str = error;\r\n        }\r\n        return str;\r\n    }\r\n    addWorkLine(terminal) {\r\n        const input = document.querySelector('[contenteditable=true]:last-child');\r\n        if (input) {\r\n            input.setAttribute('contenteditable', 'false');\r\n        }\r\n        const str = this.client.pwd().slice(5);\r\n        let newWorkLine = document.createElement('div');\r\n        newWorkLine.className = \"work__line\";\r\n        newWorkLine.innerHTML = '<span class=\"initial__entry\">guest:</span><span class=\"path\">' + '(' + str + ')' + '$' +\r\n            '</span><span id = \"input\" contenteditable=\"true\" class=\"input\" autocorrect=\"off\" autocapitalize=\"none\" autocomplete=\"off\"></span>';\r\n        terminal.appendChild(newWorkLine);\r\n    }\r\n    CommandOutput(line, terminal) {\r\n        const output = this.runCommand(Parser_1.Parser.parse(line));\r\n        if (output) {\r\n            const outputCommand = output.split('\\n');\r\n            for (const item of outputCommand) {\r\n                let div = document.createElement('div');\r\n                div.innerHTML = item;\r\n                terminal.appendChild(div);\r\n            }\r\n        }\r\n    }\r\n    sendCommand(body) {\r\n        body.addEventListener('keypress', (event) => {\r\n            if (event.code != 'Enter')\r\n                return;\r\n        });\r\n    }\r\n}\r\nexports.Terminal = Terminal;\r\n//# sourceMappingURL=Terminal.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/Terminal.js?");

/***/ }),

/***/ "./dist/fs/FileSystemClient.js":
/*!*************************************!*\
  !*** ./dist/fs/FileSystemClient.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FileSystemClient = void 0;\r\nconst FsDir_1 = __webpack_require__(/*! ./FsDir */ \"./dist/fs/FsDir.js\");\r\nconst FsFile_1 = __webpack_require__(/*! ./FsFile */ \"./dist/fs/FsFile.js\");\r\nconst Parser_1 = __webpack_require__(/*! ../Parser */ \"./dist/Parser.js\");\r\n;\r\nclass FileSystemClient {\r\n    constructor(home) {\r\n        this.home = home;\r\n        this.pointer = home.getRoot();\r\n    }\r\n    cd(pathTo) {\r\n        if (pathTo.length > 0) {\r\n            if (pathTo.length == 1 && pathTo[0] == '-') {\r\n                this.pointer = this.home.historyDir.getOldPointer();\r\n            }\r\n            else {\r\n                let childDir;\r\n                let position = 0;\r\n                do {\r\n                    if (pathTo[position] == '..') {\r\n                        this.pointer = this.pointer.parentDir;\r\n                    }\r\n                    else {\r\n                        if (pathTo[position] == 'home' && position == 0) {\r\n                            this.pointer = this.home.getRoot();\r\n                        }\r\n                        else {\r\n                            childDir = this.pointer.get(pathTo[position]);\r\n                            if (!childDir) {\r\n                                throw new Error(`${pathTo} not found`);\r\n                            }\r\n                            if (!(childDir instanceof FsDir_1.FsDir)) {\r\n                                throw new Error(`${pathTo} is not a directory`);\r\n                            }\r\n                            this.pointer = childDir;\r\n                        }\r\n                    }\r\n                    position++;\r\n                } while (position < pathTo.length);\r\n            }\r\n        }\r\n        else {\r\n            this.pointer = this.home.getRoot();\r\n        }\r\n        this.home.historyDir.add(this.pointer);\r\n        return true;\r\n    }\r\n    mkdir(path, flags) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        let elem = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    this.addDir(pathTo[position][0]);\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem));\r\n                    this.addDir(pathTo[position][indexElem]);\r\n                }\r\n                this.pointer = currentDir;\r\n                position++;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'p') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    while (elem < pathTo[position].length) {\r\n                        const childDir = this.addDir(pathTo[position][elem]);\r\n                        this.pointer = childDir;\r\n                        elem++;\r\n                    }\r\n                    this.pointer = currentDir;\r\n                    position++;\r\n                    elem = 0;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    rmdir(pathTo, flags) {\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            this.cd(pathTo.slice(0, pathTo.length));\r\n            if (this.pointer.content.length == 0) {\r\n                this.pointer.parentDir.removeThisDir(this.pointer);\r\n            }\r\n            else {\r\n                throw new Error('Directory must be empty');\r\n            }\r\n            this.pointer = currentDir;\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'p') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    this.cd(pathTo.slice(0, pathTo.length - position));\r\n                    if (this.pointer.content.length == 0) {\r\n                        this.pointer.parentDir.removeThisDir(this.pointer);\r\n                    }\r\n                    else {\r\n                        throw new Error('Directory must be empty');\r\n                    }\r\n                    this.pointer = currentDir;\r\n                    position++;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    touch(path, flags, param) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        if ((param && !this.hasAll(flags, 'd')) || (!param && this.hasAll(flags, 'd'))) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0 || (this.hasAll(flags, 'c') && flags.size == 1)) {\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    this.createFile(pathTo[position][0], this.hasAll(flags, 'c'));\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem));\r\n                    this.createFile(pathTo[position][indexElem], this.hasAll(flags, 'c'));\r\n                }\r\n                position++;\r\n                this.pointer = currentDir;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'd')) {\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.createFile(pathTo[position][0], this.hasAll(flags, 'c'), param);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.createFile(pathTo[position][indexElem], this.hasAll(flags, 'c'), param);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'r')) {\r\n                if (pathTo.length != 2) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n                if (pathTo[0].length == 1) {\r\n                    const file1 = this.getFile(pathTo[0][0]);\r\n                    if (pathTo[1].length == 1) {\r\n                        this.pushLastMode(pathTo[1][0], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[1].length - 1;\r\n                        this.cd(pathTo[1].slice(0, indexElem));\r\n                        this.pushLastMode(pathTo[1][indexElem], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[0].length - 1;\r\n                    this.cd(pathTo[0].slice(0, indexElem));\r\n                    const file1 = this.getFile(pathTo[0][indexElem]);\r\n                    this.pointer = currentDir;\r\n                    if (pathTo[1].length == 1) {\r\n                        this.pushLastMode(pathTo[1][0], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[1].length - 1;\r\n                        this.cd(pathTo[1].slice(0, indexElem));\r\n                        this.pushLastMode(pathTo[1][indexElem], file1, this.hasAll(flags, 'c'));\r\n                    }\r\n                }\r\n                this.pointer = currentDir;\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    pwd() {\r\n        const elemOfPath = [];\r\n        const currentDir = this.pointer;\r\n        while (this.pointer != this.home.getRoot()) {\r\n            elemOfPath.push(this.pointer.name);\r\n            this.pointer = this.pointer.parentDir;\r\n        }\r\n        this.pointer = currentDir;\r\n        elemOfPath.push('home');\r\n        const path = '/' + elemOfPath.reverse().join('/');\r\n        console.log(path);\r\n        return path;\r\n    }\r\n    rm(path, flags) {\r\n        const pathTo = Parser_1.Parser.parsePath(path);\r\n        if (pathTo.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        let position = 0;\r\n        const currentDir = this.pointer;\r\n        if (flags.size == 0) {\r\n            const str = [];\r\n            while (position < pathTo.length) {\r\n                if (pathTo[position].length == 1) {\r\n                    const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                    this.messageErrorFile(pathTo[position][0], elemDel);\r\n                }\r\n                else {\r\n                    const indexElem = pathTo[position].length - 1;\r\n                    this.cd(pathTo[position].slice(0, indexElem));\r\n                    const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                    this.messageErrorFile(pathTo[position][indexElem], elemDel);\r\n                }\r\n                position++;\r\n                this.pointer = currentDir;\r\n            }\r\n        }\r\n        else {\r\n            if (this.hasAll(flags, 'r', 'f', 'v') && flags.size == 3) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteDir(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.deleteDir(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                str.map(item => {\r\n                    console.log('removed ' + item);\r\n                });\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'v') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteDir(pathTo[position][0], str);\r\n                        this.messageErrorDir(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteDir(pathTo[position][indexElem], str);\r\n                        this.messageErrorDir(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                str.map(item => {\r\n                    console.log('removed ' + item);\r\n                });\r\n            }\r\n            else if (this.hasAll(flags, 'r', 'f') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteDir(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.deleteDir(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'v', 'f') && flags.size == 2) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][0], str);\r\n                        }\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][indexElem], str);\r\n                        }\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                str.map(item => {\r\n                    console.log('removed ' + item);\r\n                });\r\n            }\r\n            else if (this.hasAll(flags, 'r') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteDir(pathTo[position][0], str);\r\n                        this.messageErrorDir(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteDir(pathTo[position][indexElem], str);\r\n                        this.messageErrorDir(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'v') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        const elemDel = this.deleteFile(pathTo[position][0], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][0], str);\r\n                        }\r\n                        this.messageError(pathTo[position][0], elemDel);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        const elemDel = this.deleteFile(pathTo[position][indexElem], str);\r\n                        if (elemDel instanceof FsDir_1.FsDir) {\r\n                            this.deleteDir(pathTo[position][indexElem], str);\r\n                        }\r\n                        this.messageError(pathTo[position][indexElem], elemDel);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n                str.map(item => {\r\n                    console.log('removed ' + item);\r\n                });\r\n            }\r\n            else if (this.hasAll(flags, 'f') && flags.size == 1) {\r\n                const str = [];\r\n                while (position < pathTo.length) {\r\n                    if (pathTo[position].length == 1) {\r\n                        this.deleteFile(pathTo[position][0], str);\r\n                    }\r\n                    else {\r\n                        const indexElem = pathTo[position].length - 1;\r\n                        this.cd(pathTo[position].slice(0, indexElem));\r\n                        this.deleteFile(pathTo[position][indexElem], str);\r\n                    }\r\n                    position++;\r\n                    this.pointer = currentDir;\r\n                }\r\n            }\r\n            else if (this.hasAll(flags, 'd') && flags.size == 1) {\r\n                while (position < pathTo.length) {\r\n                    this.rmdir(pathTo[position], new Set([]));\r\n                    position++;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid flag');\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    ls(flags, pathTo) {\r\n        const elems = [];\r\n        const str = [];\r\n        const currentDir = this.pointer;\r\n        if (pathTo) {\r\n            this.cd(pathTo);\r\n        }\r\n        this.pointer.content.map(item => {\r\n            elems.push(item);\r\n            str.push(item.name);\r\n        });\r\n        if (this.hasAll(flags, 'Q')) {\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = '\"' + str[i] + '\"';\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'S')) {\r\n            for (let i = 0; i < elems.length - 1; i++) {\r\n                for (let j = i + 1; j < elems.length; j++) {\r\n                    if (elems[i].size < elems[j].size) {\r\n                        this.swap(elems, i, j);\r\n                        this.swap(str, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 't')) {\r\n            for (let i = 0; i < elems.length - 1; i++) {\r\n                for (let j = i + 1; j < elems.length; j++) {\r\n                    if (elems[i].lastmod < elems[j].lastmod) {\r\n                        this.swap(elems, i, j);\r\n                        this.swap(str, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'l')) {\r\n            let sum = 0;\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (elems[i] instanceof FsFile_1.FsFile) {\r\n                    sum += elems[i].size;\r\n                }\r\n                str[i] = this.collectString(elems[i]) + str[i];\r\n            }\r\n            str.push('total ' + sum);\r\n        }\r\n        if (this.hasAll(flags, 's')) {\r\n            let sum = 0;\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (elems[i] instanceof FsFile_1.FsFile) {\r\n                    str[i] = elems[i].size.toString() + ' ' + str[i];\r\n                    sum += elems[i].size;\r\n                }\r\n                else {\r\n                    str[i] = '0 ' + str[i];\r\n                }\r\n            }\r\n            if (!(str.includes('total ' + sum))) {\r\n                str.push('total ' + sum);\r\n            }\r\n        }\r\n        if (str.length > elems.length) {\r\n            const sumElem = str.pop();\r\n            if (sumElem) {\r\n                str.unshift(sumElem);\r\n            }\r\n        }\r\n        str.map(item => {\r\n            console.log(item);\r\n        });\r\n        this.pointer = currentDir;\r\n        return str;\r\n    }\r\n    cat(source, flags) {\r\n        const sourcePath = Parser_1.Parser.parsePath(source);\r\n        const currentDir = this.pointer;\r\n        let str = [];\r\n        let position = 0;\r\n        if (sourcePath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        while (position < sourcePath.length) {\r\n            this.getContentInSourceFile(sourcePath, str, position);\r\n            this.pointer = currentDir;\r\n            position++;\r\n        }\r\n        if (this.hasAll(flags, 'E')) {\r\n            const fullContent = str.join('\\n');\r\n            str = fullContent.split('\\n');\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = str[i] + '$';\r\n            }\r\n        }\r\n        if (this.hasAll(flags, 'n')) {\r\n            const fullContent = str.join('\\n');\r\n            str = fullContent.split('\\n');\r\n            for (let i = 0; i < str.length; i++) {\r\n                str[i] = '\\t' + (i + 1) + ' ' + str[i];\r\n            }\r\n        }\r\n        else if (this.hasAll(flags, 'b')) {\r\n            const fullContent = str.join('\\n');\r\n            str = fullContent.split('\\n');\r\n            let counter = 1;\r\n            for (let i = 0; i < str.length; i++) {\r\n                if (str[i] != '') {\r\n                    str[i] = '\\t' + counter + ' ' + str[i];\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n        console.log(str.join('\\n'));\r\n        return str;\r\n    }\r\n    echo(content) {\r\n        return content;\r\n    }\r\n    setOutputInTargetFile(targetPath, content) {\r\n        if (targetPath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        const currentDir = this.pointer;\r\n        this.putInTargetFile(targetPath, content, 1);\r\n        this.pointer = currentDir;\r\n    }\r\n    cancateOutputInTargetFile(targetPath, content) {\r\n        if (targetPath.length == 0) {\r\n            throw new Error('Invalid input');\r\n        }\r\n        const currentDir = this.pointer;\r\n        this.putInTargetFile(targetPath, content, 2);\r\n        this.pointer = currentDir;\r\n    }\r\n    help() {\r\n        const str = [\r\n            \"cd [DIR] - changes the current folder.\" /* CD */,\r\n            \"mkdir [OPTION] [DIR] - creates a directory.\" /* MKDIR */,\r\n            \"rmdir [OPTION] [DIR] - removes a directory if it is empty.\" /* RMDIR */,\r\n            \"touch [OPTION]... [FILE]... - creates a file.\" /* TOUCH */,\r\n            \"pwd - shows the path to the current directory.\" /* PWD */,\r\n            \"rm [OPTION]... [FILE]... - removes directory or file.\" /* RM */,\r\n            \"ls [OPTION]... [DIR] - shows directory contents.\" /* LS */,\r\n            \"cat [OPTION]... [FILE]... - print the contents of FILE (s) to standard output.\" /* CAT */,\r\n            \"echo [STRING] - print a string to standard output.\" /* ECHO */\r\n        ];\r\n        str.map(item => {\r\n            console.log(item);\r\n        });\r\n        return str;\r\n    }\r\n    getContentInSourceFile(source, str, index) {\r\n        if (source[index].length == 1) {\r\n            this.getContentFile(source[index][0], str);\r\n        }\r\n        else {\r\n            const indexElem = source[index].length - 1;\r\n            this.cd(source[index].slice(0, indexElem));\r\n            this.getContentFile(source[index][indexElem], str);\r\n        }\r\n    }\r\n    putInTargetFile(target, content, counter) {\r\n        if (target.length == 1) {\r\n            this.pushContentFile(target[0], content, counter);\r\n        }\r\n        else {\r\n            const indexElem = target.length - 1;\r\n            this.cd(target.slice(0, indexElem));\r\n            this.pushContentFile(target[indexElem], content, counter);\r\n        }\r\n    }\r\n    pushContentFile(path, str, counter) {\r\n        this.touch([path], new Set([]));\r\n        const file = this.pointer.get(path);\r\n        if (file instanceof FsFile_1.FsFile) {\r\n            if (counter == 1) {\r\n                file.setContent(str);\r\n            }\r\n            if (counter == 2) {\r\n                file.concatContent(str);\r\n            }\r\n        }\r\n        this.messageErrorFile(path, file);\r\n    }\r\n    getContentFile(path, str) {\r\n        const file = this.pointer.get(path);\r\n        if (file instanceof FsFile_1.FsFile) {\r\n            str.push(file.content);\r\n        }\r\n        this.messageErrorFile(path, file);\r\n    }\r\n    collectString(elem) {\r\n        const str = elem.size + ' ' + this.getMonth(elem.lastmod.getMonth()) + ' ' + this.checkTime(elem.lastmod.getDate()) + ' ' + this.checkTime(elem.lastmod.getHours()) + ':' + this.checkTime(elem.lastmod.getMinutes()) + ' ';\r\n        return str;\r\n    }\r\n    checkTime(time) {\r\n        if (time < 10) {\r\n            return '0' + time;\r\n        }\r\n        return time;\r\n    }\r\n    hasAll(set, ...elems) {\r\n        for (const elem of elems) {\r\n            if (!set.has(elem)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    deleteFile(path, str) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (fileInp instanceof FsFile_1.FsFile) {\r\n            str.push(fileInp.name);\r\n            this.pointer.remove(fileInp);\r\n        }\r\n        return fileInp;\r\n    }\r\n    deleteDir(path, str) {\r\n        const dirInp = this.pointer.get(path);\r\n        if (dirInp instanceof FsDir_1.FsDir) {\r\n            str.push(...this.removeAll(dirInp));\r\n        }\r\n        return dirInp;\r\n    }\r\n    messageErrorFile(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        if (elem instanceof FsDir_1.FsDir) {\r\n            throw new Error(`${path} is directory`);\r\n        }\r\n    }\r\n    messageErrorDir(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        if (elem instanceof FsFile_1.FsFile) {\r\n            throw new Error(`${path} is file`);\r\n        }\r\n    }\r\n    messageError(path, elem) {\r\n        if (!elem) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n    }\r\n    createFile(path, availability, param) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (!(fileInp instanceof FsFile_1.FsFile) && !availability) {\r\n            const file = new FsFile_1.FsFile(path, '');\r\n            file.updateLastMode(param);\r\n            this.pointer.add(file);\r\n        }\r\n        else if (fileInp instanceof FsFile_1.FsFile) {\r\n            fileInp.updateLastMode(param);\r\n        }\r\n    }\r\n    pushLastMode(path, file, availability) {\r\n        const fileInp = this.pointer.get(path);\r\n        if (!(fileInp instanceof FsFile_1.FsFile) && !availability) {\r\n            const file2 = new FsFile_1.FsFile(path, '');\r\n            file2.lastmod = file.lastmod;\r\n            this.pointer.add(file2);\r\n        }\r\n        else if (fileInp instanceof FsFile_1.FsFile) {\r\n            fileInp.lastmod = file.lastmod;\r\n        }\r\n    }\r\n    getFile(path) {\r\n        const file1 = this.pointer.get(path);\r\n        if (!(file1 instanceof FsFile_1.FsFile)) {\r\n            throw new Error(`${path} not found`);\r\n        }\r\n        return file1;\r\n    }\r\n    removeAll(dir) {\r\n        const str = [];\r\n        while (dir.content.length > 0) {\r\n            const elem = dir.content.pop();\r\n            if (elem) {\r\n                str.push(elem.name);\r\n            }\r\n            if (elem instanceof FsDir_1.FsDir) {\r\n                str.push(...this.removeAll(elem));\r\n            }\r\n        }\r\n        if (dir.parentDir.get(dir.name)) {\r\n            dir.parentDir.content.splice(dir.parentDir.content.indexOf(dir), 1);\r\n            str.push(dir.name);\r\n        }\r\n        return str;\r\n    }\r\n    addDir(path) {\r\n        if (!(this.pointer.checkUnit(path, \"DIR\" /* DIR */))) {\r\n            throw new Error('Directory already exists');\r\n        }\r\n        const childDir = new FsDir_1.FsDir(path);\r\n        this.pointer.add(childDir);\r\n        return childDir;\r\n    }\r\n    swap(array, i, j) {\r\n        const tmp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = tmp;\r\n    }\r\n    getMonth(index) {\r\n        let month;\r\n        switch (index) {\r\n            case 0: {\r\n                month = 'Jan';\r\n                break;\r\n            }\r\n            case 1: {\r\n                month = 'Feb';\r\n                break;\r\n            }\r\n            case 2: {\r\n                month = 'Mar';\r\n                break;\r\n            }\r\n            case 3: {\r\n                month = 'Apr';\r\n                break;\r\n            }\r\n            case 4: {\r\n                month = 'May';\r\n                break;\r\n            }\r\n            case 5: {\r\n                month = 'Jun';\r\n                break;\r\n            }\r\n            case 6: {\r\n                month = 'Jul';\r\n                break;\r\n            }\r\n            case 7: {\r\n                month = 'Aug';\r\n                break;\r\n            }\r\n            case 8: {\r\n                month = 'Sept';\r\n                break;\r\n            }\r\n            case 9: {\r\n                month = 'Oct';\r\n                break;\r\n            }\r\n            case 10: {\r\n                month = 'Nov';\r\n                break;\r\n            }\r\n            case 11: {\r\n                month = 'Dec';\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error('error');\r\n            }\r\n        }\r\n        return month;\r\n    }\r\n}\r\nexports.FileSystemClient = FileSystemClient;\r\n//# sourceMappingURL=FileSystemClient.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FileSystemClient.js?");

/***/ }),

/***/ "./dist/fs/FsDir.js":
/*!**************************!*\
  !*** ./dist/fs/FsDir.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FsDir = exports.FS_ROOT_NAME = void 0;\r\nconst FsFile_1 = __webpack_require__(/*! ./FsFile */ \"./dist/fs/FsFile.js\");\r\nexports.FS_ROOT_NAME = ':';\r\n;\r\nclass FsDir {\r\n    constructor(name) {\r\n        this._name = name;\r\n        this.content = new Array();\r\n        this.lastmod = new Date();\r\n        this._type = \"DIR\" /* DIR */;\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get size() {\r\n        let allSize = 0;\r\n        this.content.forEach(item => {\r\n            allSize += item.size;\r\n        });\r\n        this._size = allSize;\r\n        return this._size;\r\n    }\r\n    get parentDir() {\r\n        return this._parentDir;\r\n    }\r\n    add(fsUnit) {\r\n        if (fsUnit instanceof FsFile_1.FsFile) {\r\n            fsUnit.setParentDir(this);\r\n        }\r\n        else {\r\n            fsUnit._parentDir = this;\r\n        }\r\n        this.content.push(fsUnit);\r\n    }\r\n    removeThisDir(unit) {\r\n        unit.parentDir.content.splice(unit.parentDir.content.indexOf(unit), 1);\r\n    }\r\n    remove(unit) {\r\n        this.content.splice(this.content.indexOf(unit), 1);\r\n    }\r\n    get(name) {\r\n        for (const item of this.content) {\r\n            if (item.name == name) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n    checkUnit(fsUnit, type) {\r\n        for (const item of this.content) {\r\n            if (item.name == fsUnit && item.type == type) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    updateLastMode() {\r\n        this.lastmod = new Date();\r\n    }\r\n}\r\nexports.FsDir = FsDir;\r\n//# sourceMappingURL=FsDir.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FsDir.js?");

/***/ }),

/***/ "./dist/fs/FsFile.js":
/*!***************************!*\
  !*** ./dist/fs/FsFile.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FsFile = void 0;\r\n;\r\nclass FsFile {\r\n    constructor(name, content) {\r\n        this._name = name;\r\n        this._content = content;\r\n        this.setSize(content);\r\n        this.lastmod = new Date();\r\n        this._type = \"FILE\" /* FILE */;\r\n    }\r\n    setSize(content) {\r\n        try {\r\n            this._size = new Blob([content]).size;\r\n        }\r\n        catch (error) {\r\n            this._size = Buffer.byteLength(content, 'utf-8');\r\n        }\r\n    }\r\n    get type() {\r\n        return this._type;\r\n    }\r\n    get content() {\r\n        return this._content;\r\n    }\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    setContent(content) {\r\n        this._content = content;\r\n        this.setSize(this._content);\r\n    }\r\n    concatContent(content) {\r\n        const str = this._content.concat(content);\r\n        this._content = str;\r\n        this.setSize(this._content);\r\n    }\r\n    updateLastMode(param) {\r\n        if (param) {\r\n            this.lastmod = new Date(param);\r\n        }\r\n        else {\r\n            this.lastmod = new Date();\r\n        }\r\n    }\r\n    setParentDir(parrentDir) {\r\n        this._parentDir = parrentDir;\r\n    }\r\n}\r\nexports.FsFile = FsFile;\r\n//# sourceMappingURL=FsFile.js.map\n\n//# sourceURL=webpack://terminal-ui/./dist/fs/FsFile.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./dist/Terminal.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;